<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article id="bookmap_0607E44F01B444C689FF5B4B222D3F86">
    <title>GenXDM User's Guide</title>
    <para/>

    <section id="concept_overview">
        <title id="ttlN2000D">Overview</title>
        <para id="paraN20018">This book describes how <phrase id="phrsN2001D">GenXDM</phrase>
        operates within the XML life cycle. Topics covered include: 
        </para>
        <orderedlist id="ol_549F3909706448E996BDBC5D2F95628D">
            <listitem id="li_9551B57AC035441DB11385E2C86FB3EE">
                <para><ulink type="concept" url="#concept_injecting" id="linkN2002F">Injecting a GenXDM Bridge Implementation</ulink>
                explains how to prepare <phrase id="phrsN20039">GenXDM</phrase>
                for use by injecting a bridge implementation, using ProcessingContext. 
                </para>
            </listitem>
            <listitem id="li_5214A502CC5347D69A8B50B179316696">
                <para><ulink type="concept" url="#concept_reading" id="linkN20045">Reading an XML Document</ulink>
          describes how a simple XML document, received from file, URL, or socket, can be
          reviewed using DocumentHandler. 
        </para>
            </listitem>
            <listitem id="li_A041D42CD59A407BBFBB9D14FFA602EF">
                <para><ulink type="concept" url="#concept_creating" id="linkN20055">Creating an XML Docment</ulink>
          describes how a simple XML document is created (or constructed) using
          FragmentBuilder. 
        </para>
            </listitem>
            <listitem id="li_5837225E79BD4467A29772BF02FCB068">
                <para><ulink type="concept" url="#concept_examining" id="linkN20065">Examining an XML Document</ulink>
          explains how to use Model/Cursor to examine an XML document that you have read
          or constructed. 
        </para>
            </listitem>
            <listitem id="li_F778AB30C93C4CECA096602653FF437A">
                <para><ulink type="concept" url="#concept_modifying" id="linkN20075">Modifying an XML Document</ulink>
          explains how you can modify a document that you've received, or use a partner
          processor to modify a document that you created. 
        </para>
            </listitem>
            <listitem id="li_186B1ABC44A54D158F4E6B7F55AC01C7">
                <para><ulink type="concept" url="#concept_writing" id="linkN20085">Writing to a File or Socket</ulink>
          describes how you can serialize a document to a file or socket. 
        </para>
            </listitem>
            <listitem id="li_E764943786324386BB7B6A0CF0A008B1">
                <para><ulink type="concept" url="#concept_types" id="linkN20095">Implementing Types</ulink> explains
          how to use typed trees. 
        </para>
            </listitem>
        </orderedlist>
    </section>

    <section id="concept_injecting">
        <title id="ttlN7000D">Injecting a <phrase id="phrsN70012">GenXDM</phrase> Bridge Implementation</title>
        <para id="paraN7001E"> In order to use 
        <phrase id="phrsN70023">GenXDM</phrase>,
        you must implement a bridge to connect the 
        <phrase id="phrsN70029">GenXDM</phrase>
        API to the underlying data model. The choice of bridge therefore depends upon
        your preferred tree model. For example, you can inject a bridge to the Document
        Object Model (DOM). 
     </para>
        <para id="paraN70030">Once a bridge is injected, 
        <phrase id="phrsN70035">GenXDM</phrase>
        can be used without consideration of the underlying tree model. All bridges
        operate the same way. Two primary methods of bridge injection are described in
        the following sections: 
     </para>
        <itemizedlist id="ul_bridge_injection">
            <listitem id="li_79255058C8D44D4D9641E586297EB840">
                <para>
                    <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN70047">Dependency Injection Pattern</ulink>
                </para>
            </listitem>
            <listitem id="li_36AAB3D50337451696686C262D758353">
                <para>
                    <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN70057">Factory Method Pattern</ulink>
                </para>
            </listitem>
        </itemizedlist>
        <para id="paraN70063">Regardless of the pattern chosen, the end result is a
        ProcessingContext&lt;N&gt; object, or the equivalent of: 
     </para>
        <para id="paraN70069">
            <literal id="cdphN7006D">ProcessingContext&lt;N&gt; context =
          getContext(ProcessingContextFactory&lt;N&gt; factory);</literal>
        </para>
        <para id="paraN70074">Throughout the rest of this guide, this object is referred to as the 
        <emphasis role="italic" id="iN70079">context</emphasis>, whether it's a processing context for DOM, AxiOM, Cx, or
        some other bridge. All of that implementation-specific dependency has been
        either localized into the factory method, or it has been hidden through
        dependency injection. 
     </para>
        <para id="paraN70080">Once the processing context is prepared, representing
        ProcessingContext&lt;N&gt; for a &lt;N&gt;ode type, you are ready to start
        working with XML. 
     </para>
        <section id="concept_dependency_injection">
            <title id="ttlN8000D">Dependency Injection Pattern</title>
            <para id="paraN80018"> The ideal solution for implementing a bridge is to use the Dependency
        Injection pattern. When the bridge is obtained using dependency injection, the 
        <phrase id="phrsN8001D">GenXDM</phrase>
        code is not closely coupled with the actual bridge implementation. Several
        well-known Java toolkits are available for the dependency injection pattern: 
     </para>
            <itemizedlist id="ul_dependency_injection_apis">
                <listitem id="li_E63A24777D8D4C77BEFBC6E90CE5114E">
                    <para> Spring: 
          <ulink type="" url="http://www.springsource.org/" id="linkN80030">http://www.springsource.org/</ulink>
        </para>
                </listitem>
                <listitem id="li_FC26026E7BFB4CA28FE5EBB837F492CC">
                    <para>PicoContainer: 
          <ulink type="" url="http://picocontainer.org/" id="linkN80040">http://picocontainer.org/</ulink>
        </para>
                </listitem>
                <listitem id="li_D6FCD6D374144891A1DF651197872366">
                    <para>Google Guice: 
          <ulink type="" url="http://code.google.com/p/google-guice/" id="linkN80050">http://code.google.com/p/google-guice/</ulink>
          
        </para>
                </listitem>
            </itemizedlist>
            <para id="paraN8005B">JSR 330 has standardized injection in Java SE and EE, allowing you to
        choose a suitable framework for dependency injection and make use of it. 
     </para>
        </section>
        <section id="concept_factory_method">
            <title id="ttlN9000D">Factory Method Pattern</title>
            <para id="paraN90018">The 
        <literal id="cdphN9001D">bridgekit</literal> module, which is included in the 
        <phrase id="phrsN90023">GenXDM</phrase>
        code, includes an interface that can be used to loosely couple the 
        <phrase id="phrsN90029">GenXDM</phrase>
        API to a single bridge implementation. The 
        <literal id="cdphN9002F">org.genxdm.bridgekit.ProcessingContextFactory</literal> interface
        is parameterized on &lt;N&gt;ode, so can only create a ProcessingContext for
        one bridge implementation. 
     </para>
            <para id="paraN90036">If a ProcessingContextFactory is implemented and used, then it is the
        only place in the code where there is a dependency on a particular bridge
        implementation. For example, when using this pattern and the DOM bridge, the
        class that implements ProcessingContextFactory should be the only place in all
        the code that contains 
        <literal id="cdphN9003B">import org.w3c.dom.Node</literal>. 
     </para>
            <sidebar id="section_processingcontextfactory">
                <title id="ttlN90048"> ProcessingContextFactory</title>
                <para id="paraN9004E">ProcessingContextFactory contains one method: 
        </para>
                <para id="paraN90054">
                    <literal id="cdphN90058">ProcessingContext&lt;N&gt; newProcessingContext();</literal>
                </para>
                <para id="paraN9005F">with parameters varying for each bridge. 
        </para>
                <para id="paraN90065">For example, depending on the bridge type: 
        </para>
                <para id="paraN9006B">
                    <informaltable id="table_processing_context">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="5.07*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">DOM factory 
                  </entry>
                                    <entry colname="col2">
                                        <literal id="cdphN900A0">ProcessingContext&lt;Node&gt;
                        newProcessingContext();</literal>
                                    </entry>
                                </row>
                                <row>
                                    <entry colname="col1">Cx factory 
                  </entry>
                                    <entry colname="col2">
                                        <literal id="cdphN900B9">ProcessingContext&lt;XmlNode&gt;
                        newProcessingContext();</literal>
                                    </entry>
                                </row>
                                <row>
                                    <entry colname="col1">AxiOM factory 
                  </entry>
                                    <entry colname="col2">
                                        <literal id="cdphN900D2">ProcessingContext&lt;Object&gt;
                        newProcessingContext();</literal>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sidebar>
        </section>
    </section>

    <section id="concept_reading">
        <title id="ttlNA000D">Reading an XML Document with DocumentHandler</title>
        <para id="paraNA0018"><phrase id="phrsNA001C">GenXDM</phrase>
        uses DocumentHandler to read XML documents. ProcessingContext&lt;N&gt; extends
        DocumentHandlerFactory&lt;N&gt;, so the simplest way of obtaining a tool for
        parsing XML is: 
     </para>
        <para id="paraNA0023">
            <literal id="cdphNA0027">DocumentHandler&lt;N&gt; parser =
          context.newDocumentHandler();</literal>
        </para>
        <para id="paraNA002E">DocumentHandler uses the InputSource parse method to read documents: 
     </para>
        <para id="paraNA0034">
            <literal id="cdphNA0039">N parse(InputSource, URI)</literal>
        </para>
        <sidebar id="section_new_input_source">
            <title id="ttlNA0046">Create a New InputSource for Reading</title>
            <para id="paraNA004C"> InputSource is org.xml.sax.InputSource, and can represent
          InputStream, Reader, or SystemId. That is, an InputSource may be constructed
          using an InputStream, a Reader, or a (java.lang.String) URI representing the
          SystemId. 
          <note id="noteNA0051"><para>If constructing the InputSource using a URI, you must specify the
             URI using java.lang.String. Do not use java.net.URI. 
          </para></note> 
        </para>
            <itemizedlist id="ul_input_sources">
                <listitem id="li_F10B3460A44A43619B7DF0388F02A072">
                    <para><emphasis role="bold" id="bNA0063">Reading from File.</emphasis>
             If you have a variable named 
             <varname id="vrnmNA0069">file</varname>, of type 
             <literal id="cdphNA006F">java.io.File</literal>, use: 
             </para>
                    <para id="paraNA0075">
                        <literal id="cdphNA0079">Reader reader = new FileReader(file);</literal>
                    </para>
                    <para id="paraNA0086">
                        <literal id="cdphNA008A">InputSource source = new InputSource(reader);</literal>
                    </para>
                </listitem>
                <listitem id="li_807AFBBE6FE64F1FB6DD61276B594B97">
                    <para><emphasis role="bold" id="bNA0097">Reading from URI.</emphasis>
             If you have a variable named 
             <varname id="vrnmNA009D">uri</varname>, of type 
             <literal id="cdphNA00A3">java.net.URI</literal>, use: 
             </para>
                    <para id="paraNA00A9">
                        <literal id="cdphNA00AD"> URL url = uri.getURL(); // then see 'URL'</literal>
                    </para>
                </listitem>
                <listitem id="li_37CC52F6D88647219F46A599C03D30F8">
                    <para><emphasis role="bold" id="bNA00BA">Reading from URL.</emphasis>
             If you have a variable named 
             <varname id="vrnmNA00C0">url</varname>, of type 
             <literal id="cdphNA00C6">java.net.URL</literal>, use: 
             </para>
                    <para id="paraNA00CC">
                        <literal id="cdphNA00D0">InputStream stream = url.openStream();</literal>
                    </para>
                    <para id="paraNA00D7">
                        <literal id="cdphNA00DB">InputSource source = new
                  InputSource(stream);</literal>
                    </para>
                </listitem>
                <listitem id="li_7CCAA1621DF24F78808417418700CE1C">
                    <para><emphasis role="bold" id="bNA00EE">Reading from
                Socket.</emphasis> If you have a variable named 
             <varname id="vrnmNA00F4">socket</varname>, of type 
             <literal id="cdphNA00FA">java.net.Socket</literal>, use: 
             </para>
                    <para id="paraNA0100">
                        <literal id="cdphNA0104">InputStream stream = socket.getInputStream(); InputSource
                  source = new InputSource(stream);</literal>
                    </para>
                </listitem>
            </itemizedlist>
        </sidebar>
        <sidebar id="section_system_id">
            <title id="ttlNA011A">Set the System ID</title>
            <para id="paraNA0120">If you have the System ID (as a java.net.URI), set it on the
          constructed InputSource: 
        </para>
            <para id="paraNA0126">
                <literal id="cdphNA012A">source.setSystemId(systemId.toString());</literal>
            </para>
        </sidebar>
        <sidebar id="section_parse_document">
            <title id="ttlNA0138">Parse the Document</title>
            <para id="paraNA013E">
                <literal id="cdphNA0142">N document = parser.parse(source, systemId);</literal>
            </para>
        </sidebar>
        <section id="concept_error_handlers">
            <title id="ttlNB000D">Using Error Handlers and Resolvers</title>
            <para id="paraNB0018">There are several additional methods in the DocumentHandlerFactory
        interface, allowing you to get and set an error handler (XMLReporter, a
        javax.xml.stream abstraction) or to get and set a Resolver (org.genxdm.io).
        There is also a method, newDocumentHandler(XMLReporter, Resolver) that allows
        creation of a DocumentHandler&lt;N&gt; with customized error handler and
        resolver, without changing the defaults. 
     </para>
            <sidebar id="section_error_handler">
                <title id="ttlNB0024">Error Handler</title>
                <para id="paraNB002A">The error handler is used to catch problems during parse. If it's not
          possible to continue the parse, the error handler gets more detailed
          information on failures. 
        </para>
                <para id="paraNB0030">To use the error handler, create an XMLReporter, ensure that it works
          as desired, and supply it to DocumentHandlerFactory (either as the default
          handler, or as the custom handler for a single DocumentHandler). Without a
          robust XMLReporter (error handler), the parser fails on input-output problems
          or ill-formed documents, throwing an IOException or an XdmMarshalException,
          respectively. 
        </para>
            </sidebar>
            <sidebar id="section_resolver">
                <title id="ttlNB003D">Resolver</title>
                <para id="paraNB0043">In current implementations, the Resolver is never used because the
          current implementations of DocumentHandler handle only single documents,
          without inclusion handling of any sort. 
        </para>
            </sidebar>
        </section>
    </section>

    <section id="concept_creating">
        <title id="ttlNC000D">Creating an XML Document with FragmentBuilder</title>
        <para id="paraNC0018">In 
        <phrase id="phrsNC001D">GenXDM</phrase>,
        FragmentBuilder is used to create or construct an XML document in memory. 
     </para>
        <note id="noteNC0024">
            <para>This section assumes that you have a ProcessingContext&lt;N&gt;,
        called 
        <emphasis role="italic" id="iNC0029">context</emphasis>.
     </para>
        </note>
        <para id="paraNC0030">This section demonstrates the construction of a simple XML document in
        memory:
     </para>
        <para id="paraNC0036">
            <programlisting id="cdblkNC003B">&lt;?xml version="1.0"?&gt;
&lt;!-- comment --&gt;
&lt;?pi data?&gt;
&lt;element xmlns="http://localhost/" attr="value"&gt;text&lt;/element&gt;
</programlisting>
        </para>
        <para id="paraNC0043">To create this XML document in 
        <phrase id="phrsNC0048">GenXDM</phrase>,
        we use ProcessingContext, which constructs the document using the proper node
        type:
     </para>
        <para id="paraNC004F">
            <literal id="cdphNC0054">FragmentBuilder&lt;N&gt; builder =
          context.newFragmentBuilder();</literal>
        </para>
        <para id="paraNC005B">The following sections describe how to create and review this document:
     </para>
        <orderedlist id="ol_27028686524941B8A2E9B85B8DCBEAA3">
            <listitem id="li_C9024B5CFD044284BEFE58006366CB44">
                <para>
                    <ulink type="concept" url="c_Create_a_Constant_String.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkNC006C">Create the Document</ulink>
                </para>
            </listitem>
            <listitem id="li_766550023606493BA7C8F4BDAAD519E9">
                <para>
                    <ulink type="concept" url="c_Create_an_Element.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkNC007C">Create an Element</ulink>
                </para>
            </listitem>
            <listitem id="li_3AF786E88DA14D6E96F08E6B884C564E">
                <para>
                    <ulink type="concept" url="c_Access_the_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkNC008C">Access the Document</ulink>
                </para>
            </listitem>
        </orderedlist>
        <para id="paraNC0098">The document contains all seven GenXDM NodeKind-s: DOCUMENT, TEXT,
        COMMENT, PROCESSING_INSTRUCTION, ELEMENT, NAMESPACE, and ATTRIBUTE.
     </para>
        <section id="concept_create_document">
            <title id="ttlND000D">Create the Document</title>
            <para id="paraND0018"> Several tasks are part of the initial document creation: 
     </para>
            <orderedlist id="ol_E2BDE7E2202D4A0FBD843EF48334CC1D">
                <listitem id="li_B7398931044A4B96BC92E94832FC36CB">
                    <para>Create a constant string 
        </para>
                </listitem>
                <listitem id="li_3C076E6EA2F04A9C9FF2BDBB5D29C30D">
                    <para>Create the document 
        </para>
                </listitem>
                <listitem id="li_72396C8DF529498CACB2A83CCF7A993E">
                    <para>Add whitespace (embedded
          linefeeds) 
        </para>
                </listitem>
                <listitem id="li_0CE3710B0B1B452EBBE71750E74A22FC">
                    <para>Create a comment 
        </para>
                </listitem>
                <listitem id="li_B583D4F701C547B285280B785DE99FA8">
                    <para>Create a processing
          instruction 
        </para>
                </listitem>
            </orderedlist>
            <para id="paraND0048">For example: 
     </para>
            <para id="paraND004E">
                <programlisting id="cdblkND0053">final String LF = "\n"; 
builder.startDocument(null, null);
builder.text(LF); 
builder.comment("comment"); 
builder.text(LF); 
builder.processingInstruction("pi", "data"); 
builder.startElement("http://localhost/", "element", "");
builder.namespace("", "http://localhost/");
builder.attribute("", "attr", "", "value"); 
builder.text("text"); 
builder.endElement(); 
builder.text(LF); 
builder.endDocument;
</programlisting>
            </para>
            <para id="paraND005B">Use 
        <function id="apinmND0060">startDocument()</function> to create a document as &lt;N&gt;ode
        of NodeKind.DOCUMENT. 
     </para>
            <para id="paraND0067">The parameters to the startDocument() method are a URI representing the
        SystemId and an internal subset. Both of theses can be set to null, which is
        usually correct. As this document will be created in memory, there is no
        specific location. 
     </para>
            <para id="paraND006D">There are several embedded linefeeds in this document. Each must be
        created as a text node. 
     </para>
        </section>
        <section id="concept_create_element">
            <title id="ttlNE000D">Create an Element</title>
            <para id="paraNE0018">Next, create an element. 
     </para>
            <para id="paraNE001E">Elements are like documents: both are containers. Therefore, instead of
        a single method, like text() that creates a complete node at once, we provide a
        
        <function id="apinmNE0023">startElement()</function> method that opens the container. 
     </para>
            <para id="paraNE002A">startElement parameters are always given in the same order, and may
        never be null: 
     </para>
            <para id="paraNE0030">
                <informaltable id="table_startelement">
                    <tgroup cols="2">
                        <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                        <colspec colname="col2" colnum="2" colwidth="4.00*"/>
                        <tbody>
                            <row>
                                <entry colname="col1">namespace URI 
                </entry>
                                <entry colname="col2">The domain for the name. To indicate a global
                  namespace, specify an empty string: 
                  <literal id="cdphNE0066">""</literal> 
                </entry>
                            </row>
                            <row>
                                <entry colname="col1">local name 
                </entry>
                                <entry colname="col2">The name itself.
                </entry>
                            </row>
                            <row>
                                <entry colname="col1">prefix 
                </entry>
                                <entry colname="col2">The binding for the namespace in this scope.
                  Note that, for this document, the default prefix is not in the global
                  namespace, but is bound to the namespace 
                  <literal id="cdphNE0094">http://localhost/ ""</literal>. 
                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <sidebar id="section_namespace_creation">
                <title id="ttlNE00A6">Namespace Creation</title>
                <para id="paraNE00AC">Only two parameters are used for namespace creation: 
        </para>
                <para id="paraNE00B2">
                    <informaltable id="table_namespace_parameters">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="3.72*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">name/bound prefix 
                  </entry>
                                    <entry colname="col2">The (bound) prefix is used as the name of
                     the namespace. 
                  </entry>
                                </row>
                                <row>
                                    <entry colname="col1">namespace URI 
                  </entry>
                                    <entry colname="col2"> 
                  </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sidebar>
            <sidebar id="section_attribute_creation">
                <title id="ttlNE0109">Attribute Creation</title>
                <para id="paraNE010F">The parameters used to create an attribute are nearly the same as
          those used to create the containing element: 
        </para>
                <para id="paraNE0115">
                    <informaltable id="table_attribute_parameters">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="4.00*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">namespace URI 
                  </entry>
                                    <entry colname="col2">The domain for the name. To indicate a
                     global namespace, specify an empty string: 
                     <literal id="cdphNE014B">""</literal> 
                  </entry>
                                </row>
                                <row>
                                    <entry colname="col1">local name 
                  </entry>
                                    <entry colname="col2">The name itself.
                  </entry>
                                </row>
                                <row>
                                    <entry colname="col1">prefix 
                  </entry>
                                    <entry colname="col2">The binding for the namespace in this
                     scope. Note that, for this document, although this attribute has the same
                     (default) prefix as its containing element, it is not in the same namespace. 
                  </entry>
                                </row>
                                <row>
                                    <entry colname="col1">value 
                  </entry>
                                    <entry colname="col2">The value of the attribute. 
                  </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sidebar>
            <sidebar id="section_adding_text">
                <title id="ttlNE019A">Adding Text</title>
                <para id="paraNE01A0">To add text to the document, use the 
          <function id="apinmNE01A5">text()</function> method. The example shows a text node
          containing the word "text". 
        </para>
                <para id="paraNE01AC"> text() is a child of the element node. It is a child because
          startElement() has been called, but endElement() has not. 
        </para>
            </sidebar>
        </section>
        <section id="concept_close_containers">
            <title id="ttlNF000D">Close Containers</title>
            <para id="paraNF0018">To complete the document creation, end the element and document, closing
        the containers.
     </para>
            <para id="paraNF001E">To complete the element, call 
        <function id="apinmNF0023">endElement()</function>, so the element has no further children. 
     </para>
            <para id="paraNF002A">A final text(LF) method finishes adds a new line at the end of the
        document, and then end the document by calling 
        <function id="apinmNF002F">endDocument()</function>. 
     </para>
        </section>
        <section id="concept_access_document">
            <title id="ttlN10000D">Access the Document</title>
            <para id="paraN100018">The document created is now stored in memory. To access the document,
        use: 
     </para>
            <para id="paraN10001E">
                <literal id="cdphN100022">N doc = builder.getNode();</literal>
            </para>
            <para id="paraN100029">FragmentBuilder&lt;N&gt; extends NodeSource&lt;N&gt;, which is an
        interface offering a tool that is capable of creating a single node or a
        sequence of nodes. Its two methods are: 
     </para>
            <itemizedlist id="ul_nodesource_methods">
                <listitem id="li_B7D0B6C86F0348A3B93C988F75FD9933">
                    <para>
                        <function id="apinmN10003A">N
             getNode();</function>
                    </para>
                </listitem>
                <listitem id="li_ADE39DE044104ED3ADB3D0D6D42C426B">
                    <para>
                        <function id="apinmN100046">List&lt;N&gt;
             getNodes();</function>
                    </para>
                </listitem>
            </itemizedlist>
            <para id="paraN10004E">If a sequence of nodes has been created, and getNode() is called, only
        the first node is returned. However, the most common usage of FragmentBuilder
        is to create a tree rooted at a single node, so getNode() is provided to make
        this most-common use case more convenient 
     </para>
        </section>
    </section>

    <section id="concept_examining">
        <title id="ttlN11000D">Examining an XML Document with Model/Cursor</title>
        <para id="paraN110018"><phrase id="phrsN11001C">GenXDM</phrase>
        employs Model/Cursor to examine XML documents. 
     </para>
        <para id="paraN110023">
            <note id="noteN110028">
                <para>This section assumes that: 
          </para>
                <itemizedlist id="ul_examine_assumptions">
                    <listitem id="li_06573B1A6D854C3FA1E899B9F7A819A0">
                        <para><emphasis role="italic" id="iN110038">context</emphasis> is the
                ProcessingContext&lt;N&gt; created in 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN11003E">Injecting a GenXDM Bridge Implementation</ulink>.
                
             </para>
                    </listitem>
                    <listitem id="li_B2DBAF5083FA4E7494E0FD4CFCE8D710">
                        <para><emphasis role="italic" id="iN11004E">document</emphasis> is the
                the document read in 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN110054">Reading an XML Document with DocumentHandler</ulink>.
                
             </para>
                    </listitem>
                </itemizedlist>
            </note>
        </para>
        <para id="paraN110062">This section describes how a retrieved document is processed. The
        details of the processing depend upon the application's needs and the structure
        of the XML, which is presumably known in advance. 
     </para>
        <para id="paraN110068">The descriptions and examples that follow refer to the document below,
        which is a variant of the po.xml described in the W3C XML Schema Primer: 
     </para>
        <para id="paraN11006E">
            <programlisting id="cdblkN110073"><![CDATA[<?xml version="1.0"?>
<purchaseOrder orderDate="1999-10-20">
   <shipTo country="US">
      <name>Alice Smith</name>
      <street>123 Maple Street</street>
      <city>Mill Valley</city>
      <state>CA</state>
      <zip>90952</zip>
   </shipTo>
   <billTo country="US">
      <name>Robert Smith</name>
      <street>8 Oak Avenue</street>
      <city>Old Town</city>
      <state>PA</state>
      <zip>95819</zip>
   </billTo>
   <creditcard type="Visa" 
expiration="2011-08">4444333322221111</creditcard>
   <items>
      <item partNum="872-AA">
         <productName>Lawnmower</productName>
         <quantity>1</quantity>
         <USPrice>148.95</USPrice>
         <comment>Confirm this is electric</comment>
      </item>
   </items>
</purchaseOrder>
]]></programlisting>
        </para>
        <section id="concept_model_vs_cursor">
            <title id="ttlN12000D">Understanding Model and Cursor</title>
            <para id="paraN120018"><phrase id="phrsN12001C">GenXDM</phrase>
        offers two tools for navigating and examining an XML document. Model and Cursor
        provide mostly equivalent functionality, and have similar APIs. The primary
        difference between the two is how state is maintained. 
     </para>
            <sidebar id="section_model">
                <title id="ttlN120029">Model</title>
                <para id="paraN12002F"> Model is stateless. Every method in Model takes, as a first argument,
          a 
          <emphasis role="italic" id="iN120034">context node</emphasis>. You can use Model over multiple documents: supply
          a context node for a different tree, and the Model immediately addresses it. 
        </para>
                <para id="paraN12003B"> To use Model to navigate and inspect an XML document: 
        </para>
                <para id="paraN120041">
                    <literal id="cdphN120045">Model&lt;N&gt; model = context.getModel();</literal>
                </para>
            </sidebar>
            <sidebar id="section_cursor">
                <title id="ttlN120053">Cursor</title>
                <para id="paraN120059">Cursor maintains positional state. That is, methods in Cursor use the
          node over which the Cursor is positioned as the context node. This means that a
          Cursor is intended for use only for a single document tree. After getting a new
          document, you should create a new Cursor. 
        </para>
                <para id="paraN12005F">Because Cursor carries positional state, it is possible to walk
          through a document in modular steps, passing the Cursor to multiple methods or
          multiple classes in turn. The operating assumption is that the state of the
          Cursor will have changed by the end of each module's operation. 
        </para>
                <para id="paraN120065">To use Cursor to navigate and inspect and XML document: 
        </para>
                <para id="paraN12006B">
                    <literal id="cdphN12006F">Cursor&lt;N&gt; cursor = context.getCursor();</literal>
                </para>
            </sidebar>
            <section id="concept_structural_navigation">
                <title id="ttlN13000D">Structural Navigation</title>
                <para id="paraN130018">Structural navigation allows you to find other nodes based on structural
        relationships between two nodes. 
     </para>
                <para id="paraN13001E">The results can be surprising. In particular, most XML contains
        whitespace (linefeeds and tabs or spaces) so that it shows up like the po.xml
        document above, on multiple lines with indentation. In the XML, these spaces
        are represented as text nodes. So the first child node of the document node is
        actually a text node, not the 
        <literal id="cdphN130023">&lt;purchaseOrder&gt;</literal> element. The first child 
        <emphasis role="italic" id="iN130029">element</emphasis> of the document node is the 
        <literal id="cdphN13002F">&lt;purchaseOrder&gt;</literal> element. 
     </para>
                <para id="paraN130036">Most XML processing is concerned primarily with the content of elements
        and attributes. The textual content of element nodes are actually text nodes,
        in the XQuery Data Model. 
     </para>
                <para id="paraN13003C">The methods that can be used for structural navigation include: 
     </para>
                <para id="paraN130042">
                    <informaltable id="table_structural_navigation_methods">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="*"/>
                            <colspec colname="col2" colnum="2" colwidth="*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">N getRoot(N); 
                </entry>
                                    <entry colname="col2">get the document node, or the root if this is
                  a fragment 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1"> N getParent(N); 
                </entry>
                                    <entry colname="col2">get the parent of the target node, which must
                  be an element or document node 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getFirstChild(N); 
                </entry>
                                    <entry colname="col2">get the first ... 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getLastChild(N); 
                </entry>
                                    <entry colname="col2">or last child of the target node, which will 
                  <emphasis role="italic" id="iN1300B4">never</emphasis> be a document, attribute, or namespace node, but may
                  be an element, text, comment, or processing instruction. This method only works
                  if the target is a document or element node (nobody else has children). 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getNextSibling(N); 
                </entry>
                                    <entry colname="col2">get the next ... 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getPreviousSibling(N); 
                </entry>
                                    <entry colname="col2">or previous sibling, if the target node is an
                  element, text, comment, or processing instruction. The returned node may be an
                  element, text, comment, or processing instruction node. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getFirstChildElement(N); 
                </entry>
                                    <entry colname="col2">get the first child ... 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getNextSiblingElement(N); 
                </entry>
                                    <entry colname="col2">or the next sibling element. These are
                  'filtered' results similar to getFirstChild(N) and getNextSibling(N); they will
                  skip over text, comment, and processing instruction node results. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getFirstChildElementByName(N, String,
                  String); 
                </entry>
                                    <entry colname="col2">get the first child ... 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getNextSiblingElementByName(N, String,
                  String); 
                </entry>
                                    <entry colname="col2">or the next sibling element that matches the
                  indicated namespace (second argument) and local name (third argument). This is
                  a further filter of the getFirstChildElement(N) and getNextSiblingElement(N)
                  methods, which skips not only text, comment, and processing instruction nodes,
                  but also skips elements that do not have the name desired. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">N getAttribute(N, String, String); 
                </entry>
                                    <entry colname="col2">equivalent to getChildElementByName, only for
                  attributes instead of child elements. This method only works if the target is
                  an element node and contains an attribute with the specified namespace and
                  name. 
                </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </section>
            <section id="concept_axis_navigation">
                <title id="ttlN14000D">Axis Navigation</title>
                <note id="noteN140018">
                    <para>Axis navigation is available only in the Model. Cursor cannot be used
        with axis navigation. 
     </para>
                </note>
                <para id="paraN14001E">Axis navigation is a form of navigation that processes axes. XPath and
        XQuery define a number of "axes", which are sequences of similar nodes,
        starting from one point in the document and accumulating based on a pattern.
        Many XML documents contain chunks of repetitive structure, with varying data
        inside the structures. Axis navigation makes processing these chunks
        straightforward. 
     </para>
                <para id="paraN140024">For example, consider a 
        <literal id="cdphN140029">library</literal> element that contains a number of 
        <literal id="cdphN14002F">book</literal> elements. Each book element has a title, author,
        unit price, and quantity. Using axis navigation, for each book in the library
        you could: 
     </para>
                <itemizedlist id="ul_axis_utility">
                    <listitem id="li_49D01C689F1E4644B4D0E611DA18D3F4">
                        <para>Look up the quantity
          available for each title. 
        </para>
                    </listitem>
                    <listitem id="li_19BF4A61523B42E48374C14857ECC9BF">
                        <para>Compare the quantity desired
          with the quantity available. 
        </para>
                    </listitem>
                    <listitem id="li_C31BA22DF8FB4886ADB754E90D2BD154">
                        <para>Calculate the cost of an
          order by multiplying the quantity. 
        </para>
                    </listitem>
                    <listitem id="li_4ADB9BCB64B54931A0E6A921D96F5AF6">
                        <para>Add the book subtotal to the
          order total. 
        </para>
                    </listitem>
                </itemizedlist>
                <sidebar id="section_axis_types">
                    <title id="ttlN14005F">Axis Types</title>
                    <para id="paraN140065">There are four axes that together partition a document into pieces.
          The four axes are: 
        </para>
                    <itemizedlist id="ul_axes">
                        <listitem id="li_CC2B56296CE9405082635B1237250A59">
                            <para><emphasis role="bold" id="bN140076">Ancestor</emphasis>. The
             ancestor axis is accumulated, in effect, by calling getParent(N) recursively
             (replacing the context node with its parent), until the root is reached. 
             </para>
                            <itemizedlist id="ul_ancestor">
                                <listitem id="li_F10776AD5C234973B68CDFDF3596ABE6">
                                    <para>Iterable&lt;N&gt;
                  getAncestorAxis(N) 
                </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem id="li_5603B8B40F7643469034CAD60C87376C">
                            <para><emphasis role="bold" id="bN140090">Descendant</emphasis>. The
             descendant axis includes all of the children (but no namespaces or attributes)
             of the context node, recursively. However, recall that only document and
             element nodes have children. 
             </para>
                            <itemizedlist id="ul_descendant">
                                <listitem id="li_C2A4FDBF13B34E6F9F40FB3BEADCC0A0">
                                    <para>Iterable&lt;N&gt;
                  getDescendantAxis(N) 
                </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem id="li_46E35DC65E664725AA2861BAF73E62EF">
                            <para><emphasis role="bold" id="bN1400AA">Following</emphasis>. The
             following axis includes all nodes in the tree which are not descendants of the
             context node, and which appear after the context node in document order. 
             </para>
                            <itemizedlist id="ul_following">
                                <listitem id="li_D6D3D377CA7A43A0952B457DF7311F3A">
                                    <para>Iterable&lt;N&gt;
                  getFollowingAxis(N) 
                </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                        <listitem id="li_746193E9C4024FF09021B03786EA116F">
                            <para><emphasis role="bold" id="bN1400C4">Preceding</emphasis>. The
             preceding axis includes all nodes in the tree which are not ancestors of the
             context node, and which appear before the context node in document order. 
             </para>
                            <itemizedlist id="ul_preceding">
                                <listitem id="li_1E92DEE6DD3C470DB5A499D0384DA04F">
                                    <para>Iterable&lt;N&gt;
                  getPrecedingAxis(N) 
                </para>
                                </listitem>
                            </itemizedlist>
                        </listitem>
                    </itemizedlist>
                </sidebar>
                <sidebar id="section_orself">
                    <title id="ttlN1400E1">Common and 
        <emphasis role="italic" id="iN1400E6">orSelf</emphasis> Axes</title>
                    <para id="paraN1400ED">Most axis navigation methods return, as the first node of the
          iterable, a node in a specified relation/pattern to the context node. However,
          two methods differ in that the first N in the returned iterable is the context
          node supplied. These orSelf methods are: 
        </para>
                    <itemizedlist id="ul_orself">
                        <listitem id="li_5F62E14DDF4F4971899C7B6CE3C8E530">
                            <para>Iterable&lt;N&gt;
             getAncestorOrSelfAxis(N) 
          </para>
                        </listitem>
                        <listitem id="li_6C515DB751254D72BE16093E304153A4">
                            <para>Iterable&lt;N&gt;
             getDescendantOrSelfAxis(N) 
          </para>
                        </listitem>
                    </itemizedlist>
                </sidebar>
                <sidebar id="section_navigating_axes">
                    <title id="ttlN14010F">Navigating Using Axes</title>
                    <para id="paraN140115"> 
        </para>
                    <para id="paraN14011B">Axes can navigate over following (next) siblings and preceding
          (previous) siblings (reverse order), and over children, child elements, and
          child elements of a given name. Similarly, you can iterate over attributes and
          namespaces. These methods include: 
        </para>
                    <itemizedlist id="ul_more_axes">
                        <listitem id="li_211AF578846849208C99F18E76DCDEC1">
                            <para>Iterable&lt;N&gt;
             getFollowingSiblingAxis(N) 
          </para>
                        </listitem>
                        <listitem id="li_F83BC834C3294C938CD92314E0D2CF6F">
                            <para>Iterable&lt;N&gt;
             getPrecedingSiblingAxis(N) 
          </para>
                        </listitem>
                        <listitem id="li_204E879D65E54D478C9039FDAE461AF5">
                            <para>Iterable&lt;N&gt;
             getChildAxis(N) 
          </para>
                        </listitem>
                        <listitem id="li_9760A5D435D643DE884A206C10013CC1">
                            <para>Iterable&lt;N&gt;
             getChildElements(N) 
          </para>
                        </listitem>
                        <listitem id="li_D0A33A0B7D0E4388AA326FA18965C54C">
                            <para>Iterable&lt;N&gt;
             getChildElementsByName(N) 
          </para>
                        </listitem>
                        <listitem id="li_A93327C8F3184D5FAEEC92AF24FCF61A">
                            <para>Iterable&lt;N&gt;
             getAttributeAxis(N, boolean) 
          </para>
                        </listitem>
                        <listitem id="li_750967BCAC58409DBE21C85AFC0C2EF0">
                            <para>Iterable&lt;N&gt;
             getNamespaceAxis(N, boolean) 
          </para>
                        </listitem>
                    </itemizedlist>
                    <note id="noteN140159">
                        <para>It is not possible to iterate over only text nodes, or only comment
          nodes, or only processing instruction nodes. It is possible, however, to filter
          these using, for instance, the descendant axis of the document node, and the
          'matches' method, checking the NodeKind. 
        </para>
                    </note>
                    <para id="paraN14015F">An example using axis navigation is provided in the 
          <ulink type="concept" url="c_Example_Informational_Submit.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN140164">Submit the Bill to the Processor</ulink>
          step of 
          <ulink type="concept" url="c_Example_Informational_Methods.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN14016E">Example: Credit Card Processing</ulink>.
          
        </para>
                </sidebar>
            </section>
            <section id="concept_informational_methods">
                <title id="ttlN15000D">Informational Methods</title>
                <para id="paraN150018">There are informational methods in both Model and Cursor that are useful
        for discerning information about nodes. Note that the Cursor methods do not
        take the context-node first argument. 
     </para>
                <para id="paraN15001E">
                    <informaltable id="table_informational_methods">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="1.89*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1"> getBaseURI(N) 
                  <para id="paraN15004D">getDocumentURI(N) 
                  </para> 
                </entry>
                                    <entry colname="col2">Both document URI and base URI are available
                  when the underlying tree model supports them. These methods are useful when
                  resolving imports and inclusions 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">hasAttributes(N) 
                  <para id="paraN150067">hasNamespaces(N) 
                  </para> 
                  <para id="paraN15006D">hasChildren(N) 
                  </para> 
                  <para id="paraN150073">hasParent(N) 
                  </para> 
                  <para id="paraN150079">hasNextSibling(N) 
                  </para> 
                  <para id="paraN15007F">hasPreviousSibling(N) 
                  </para> 
                </entry>
                                    <entry colname="col2"> These methods allow you to ask nodes about
                  their relationships, without calling node-accessor methods and checking for
                  null. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">isAttribute(N) 
                  <para id="paraN150099">isNamespace(N) 
                  </para> 
                  <para id="paraN15009F">isElement(N) 
                  </para> 
                  <para id="paraN1500A5">isTest(N) 
                  </para> 
                </entry>
                                    <entry colname="col2">You can also ask a node what it is, similar
                  to calling getNodeKind(N) and interpreting the results. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">isId(N) 
                  <para id="paraN1500BF"> isIdRefs(N) 
                  </para> 
                </entry>
                                    <entry colname="col2"> These methods tell you whether an attribute
                  is of type ID, or an element has an attribute of type ID, or if an attribute is
                  of type IDREF or IDREFS. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">getAttributeNames(N, boolean) 
                  <para id="paraN1500D9">getAttributeStringValue(N, String, String) 
                  </para> 
                  <para id="paraN1500DF">getNamespaceNames(N, boolean) 
                  </para> 
                  <para id="paraN1500E5">getNamespaceForPrefix(N, String) 
                  </para> 
                  <para id="paraN1500EB">getNamespaceBindings(N) 
                  </para> 
                </entry>
                                    <entry colname="col2">These methods allow you to examine attributes
                  and namespaces without getting these nodes as nodes. Note that
                  getNamespaceBindings() allows an underlying tree model to represent namespaces
                  as something other than nodes. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">NodeKind getNodeKind(); 
                </entry>
                                    <entry colname="col2">Tells you which of DOCUMENT, ELEMENT,
                  ATTRIBUTE, NAMESPACE, TEXT, COMMENT, and PROCESSING_INSTRUCTION this node is.
                  This is most useful to distinguish between text, comment, processing
                  instruction, and element nodes, when navigating over children, or between
                  element and document nodes when navigating over ancestors. You'll generally
                  know when you're investigating attributes and namespaces. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">String getNamespaceURI(N); 
                  <para id="paraN150119">String getLocalName(N); 
                  </para> 
                  <para id="paraN15011F"> String getPrefix(N); 
                  </para> 
                </entry>
                                    <entry colname="col2">Get the full qualified name of this node, if
                  it has one: its namespace URI (element, attribute, and namespace nodes), its
                  prefix (element and attribute nodes only), and its local name (element,
                  attribute, namespace, and processing instruction nodes). 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">boolean matches(N, NodeKind, String, String);
                  
                  <para id="paraN150139">boolean matches(N, String, String); 
                  </para> 
                </entry>
                                    <entry colname="col2">The first of these checks whether the
                  NodeKind of the target node matches the supplied NodeKind. Then, for both
                  methods, it checks whether the supplied namespace and local name match the
                  namespace and local name of the target node. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1"> String getStringValue(N); 
                </entry>
                                    <entry colname="col2"> Returns the string value of the node. For
                  comment, processing instruction, text, attribute, and namespace nodes, this is
                  the 'value' of the node. For document and element nodes, it is the value of all
                  its descendant text and element nodes. 
                </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para id="paraN150160">Several of these methods are used in the examples below. 
     </para>
            </section>
        </section>
        <section id="concept_inspecting_nodes">
            <title id="ttlN16000D">Inspect the Model</title>
            <para id="paraN160018">You can determine many things about a node using the 
        <phrase id="phrsN16001D">GenXDM</phrase>
        API. For example, with the tools described in 
        <ulink type="concept" url="c_Informational_Methods.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN160023">Informational Methods</ulink>,
        an application could navigate over the provided document to print a shipping
        label: 
     </para>
            <para id="paraN16002E">
                <programlisting id="cdblkN160033">Ship to:
Alice Smith
123 Maple Street
Mill Valley, CA 90952
</programlisting>
            </para>
            <para id="paraN16003B">For details, see 
        <ulink type="concept" url="c_Example_Using_Model.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN160040">Example: Inspection Using Model</ulink>
        and 
        <ulink type="concept" url="c_Example_Using_Cursor.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN16004A">Example: Inspection Using Cursor</ulink>.
        
     </para>
            <para id="paraN160055">Axis navigation can also be used to inspect a document. For an example,
        see 
        <ulink type="concept" url="c_Example_Informational_Methods.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN16005A">Example: Credit Card Processing</ulink>.
     </para>
            <section id="concept_model_example">
                <title id="ttlN17000D">Example: Inspection Using Model</title>
                <informalexample id="example_E40B4BE7BEC742FB8069C1D1AC973A7F">
                    <para id="paraN17001E">This example uses Model to inspect the po.xml document provided at the
          top of the 
          <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN170023">Examining an XML Document with Model/Cursor</ulink>
          section and prints an address label. 
        </para>
                    <para id="paraN17002E">The example assumes a method, implemented elsewhere, that allows us to
          get a PrintWriter that sends a job to the local label printer: 
        </para>
                    <para id="paraN170034">
                        <programlisting id="cdblkN170039">PrintWriter printer = getPrinter();
printer.println("Ship to:");
</programlisting>
                    </para>
                    <para id="paraN170041">It's very common to move from the document node to the first (and
          only) child element as the first act of XML processing. In this case, you
          "know" that this is a 
          <literal id="cdphN170046">purchaseOrder</literal> element. However, you could test this,
          if there were a chance of receiving some other document type. 
        </para>
                    <orderedlist id="ol_AA6482910AB14A8BB37BEEF2E9669E4A">
                        <listitem id="li_2166E4677FC1450EBF005BC457C39F49">
                            <para>Get the first element: 
             </para>
                            <para id="paraN170059">
                                <literal id="cdphN17005D">Model&lt;N&gt; model = context.getModel(); 
                </literal>
                            </para>
                            <para id="paraN170064">
                                <literal id="cdphN170068">N node = model.getFirstChildElement(document);</literal>
                            </para>
                        </listitem>
                        <listitem id="li_29D7265856204BADBDBBD82B68162079">
                            <para>Get the desired elements
             in order: 
             </para>
                            <para id="paraN170076">
                                <literal id="cdphN17007A">node = model.getFirstChildElementByName(node, "",
                  "shipTo");</literal>
                            </para>
                            <para id="paraN170081">Here, assume that the child elements of the 
                <literal id="cdphN170086">purchaseOrder</literal> may appear in any order. 
             </para>
                            <para id="paraN17008D">Next, assume that the order of elements inside an address must
                appear in the order given, but verify at each step that it's the right thing.
                Also, note that if desired you can assign a new value to the same N variable
                that you supply as the context. 
             </para>
                        </listitem>
                        <listitem id="li_99893B9484604F55B2AC775EF7BD5CF7">
                            <para>Get the string value of
             the text node. 
             </para>
                            <para id="paraN17009A">
                                <programlisting id="cdblkN17009F">node = model.getFirstChildElement(node);
if (model.matches("", "name"))
    printer.println(model.getStringValue(node));
</programlisting>
                            </para>
                            <para id="paraN1700A7">Here you can take a shortcut. Because you know that the 
                <literal id="cdphN1700AC">name</literal> element contains a single text node with the
                value that you want, you can navigate to that text node, and get the string
                value of the text node. Since there is only one text node, you can take
                advantage of the fact that the string value of an element node is the string
                value of its children, concatenated, and if there's only one, then the string
                value of the single child is the string value of the node. 
             </para>
                        </listitem>
                        <listitem id="li_BA19D500CEA34CB1BA72D769BD701DB0">
                            <para>Format the string. 
             </para>
                            <para id="paraN1700BA">
                                <literal id="cdphN1700BE">model.getFirstChild(node)</literal>
                            </para>
                            <para id="paraN1700C5">The string value of the 
                <literal id="cdphN1700CA">shipTo</literal> element contains extra carriage returns,
                which are not desirable for label printing: 
             </para>
                            <para id="paraN1700D1">
                                <programlisting id="cdblkN1700D6">Alice Smith
123 Maple Street
Mill Valley
CA
90952</programlisting>
                            </para>
                            <para id="paraN1700DE">To get the string in a more appropriate format: 
             </para>
                            <para id="paraN1700E4">
                                <programlisting id="cdblkN1700E9">node = model.getNextSiblingElement(node);
if (model.matches("", "street"))
    printer.println(model.getStringValue(node));
node = model.getNextSiblingElement(node);

if (model.matches("", "city"))
    printer.print(model.getStringValue(node) + ", ");
node = model.getNextSiblingElement(node);

if (model.matches("", "state"))
    printer.print(model.getStringValue(node) + " ");
node = model.getNextSiblingElement(node);

if (model.matches("", "zip"))
    printer.println(model.getStringValue(node));
</programlisting>
                            </para>
                        </listitem>
                    </orderedlist>
                </informalexample>
            </section>
            <section id="concept_cursor_example">
                <title id="ttlN18000D">Example: Inspection Using Cursor</title>
                <informalexample id="example_1A7EC11520664913AD5BD6D1CBBB0A31">
                    <para id="paraN18001E">This example uses Cursor to inspect the po.xml document provided at
          the top of the 
          <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN180023">Examining an XML Document with Model/Cursor</ulink>
          section and prints an address label. 
        </para>
                    <para id="paraN18002E">The primary difference between this and the Model example is that the
          Cursor has positional state. Instead of keeping track of state yourself, using
          N node, the cursor "moves to" a location. 
        </para>
                    <para id="paraN180034">
                        <programlisting id="cdblkN180039">PrintWriter printer = getPrinter();
printer.println("Ship to:");
Cursor&lt;N&gt; cursor = context.newCursor(document);

cursor.moveToFirstChildElement();
</programlisting>
                    </para>
                    <!--note id="noteN180041">
                        <para>With Cursor, you do not need to supply the context node. The
          context is implicit; it's the cursor's state. Also, the method names are
          slightly different: 
          <literal id="cdphN180046">moveTo</literal> instead of 
          <literal id="cdphN18004C">get.</literal> 
        </para>
                    </note-->
                    <para id="paraN180053">
                        <programlisting id="cdblkN180058">cursor.moveToFirstChildElementByName("", "shipTo"); 
cursor.moveToFirstChildElement(); 
if (cursor.matches("", "name"))
    printer.println(cursor.getStringValue());
cursor.moveToNextSiblingElement();
if (cursor.matches("", "street"))
    printer.println(cursor.getStringValue());
cursor.moveToNextSiblingElement();
if (cursor.matches("", "city"))
    printer.print(cursor.getStringValue() + ", "); 
cursor.moveToNextSiblingElement();
if (cursor.matches("", "state"))
    printer.print(cursor.getStringValue() + " "); 
cursor.moveToNextSiblingElement();
if (cursor.matches("", "zip"))
    printer.println(cursor.getStringValue());
</programlisting>
                    </para>
                </informalexample>
            </section>
            <section id="concept_credit_card_example">
                <title id="ttlN19000D">Example: Credit Card Processing</title>
                <para id="paraN190018">This example uses methods described in 
        <ulink type="concept" url="c_Informational_Methods.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN19001D">Informational Methods</ulink>
        to examine and process an order form. In order to process the example credit
        card, you will verify the card authorization data. Authorization returns a 
        <literal id="cdphN190027">chargeID</literal>, which is then sent, along with the amount
        charged and the 
        <literal id="cdphN19002D">merchantID</literal>, to the card processor.
     </para>
                <para id="paraN190034">The steps needed are described in the sections below:
     </para>
                <orderedlist id="ol_F92713B439614F58ACF7D27AE3382394">
                    <listitem id="li_68B40A96BDC848168FD3EFE94ADAF886">
                        <para>
                            <ulink type="concept" url="c_Example_Informational_Verify.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN190045">Verify the Credit Card Information</ulink>
                        </para>
                    </listitem>
                    <listitem id="li_6408FD4291E54E099B11B06C7EB2CC8C">
                        <para>
                            <ulink type="concept" url="c_Example_Informational_Add_Data.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN190055">Add Data from the Credit Card Element</ulink>
                        </para>
                    </listitem>
                    <listitem id="li_0982365B9F7743B8BC683434586EFA16">
                        <para>
                            <ulink type="concept" url="c_Example_Informational_Submit.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN190065">Submit the Bill to the Processor</ulink>
                        </para>
                    </listitem>
                </orderedlist>
                <section id="concept_verify_credit_card">
                    <title id="ttlN1A000D">Verify the Credit Card Information</title>
                    <para id="paraN1A0018">In this example, the card processor expects the data formatted as: 
     </para>
                    <para id="paraN1A001E">
                        <literal id="cdphN1A0022">NAME\nADDRESS\nCITY, STATE ZIP\nCARDNUM\nEXPIRATION</literal>
                    </para>
                    <para id="paraN1A0029">In order to retrieve this data from the form, use a use a simple
        navigation and error checking method, similar to that used in the previous
        example on Inspection, this time assuming N 
        <emphasis role="italic" id="iN1A002E">document</emphasis>, N 
        <emphasis role="italic" id="iN1A0034">node</emphasis>, and Model&lt;N&gt; 
        <emphasis role="italic" id="iN1A003A">model</emphasis>: 
     </para>
                    <para id="paraN1A0041">
                        <programlisting id="cdblkN1A0046">node = model.getFirstChildElement(document);
node = model.getFirstChildElementByName(node, "", "billTo");

StringBuilder buffer = new StringBuilder(); 
N buyerNode = model.getFirstChildElement(node); 
if (model.matches(buyerNode, "", "name"))
    buffer.append(model.getStringValue(buyerNode) + "\n"); 
buyerNode = model.getNextSiblingElement(buyerNode);
if (model.matches(buyerNode, "", "street"))
    buffer.append(model.getStringValue(buyerNode) + "\n"); 
buyerNode = model.getNextSiblingElement(buyerNode);
if (model.matches(buyerNode, "", "city"))
    buffer.append(model.getStringValue(buyerNode) + ", "); 
buyerNode = model.getNextSiblingElement(buyerNode);
if (model.matches(buyerNode, "", state"))
    buffer.append(model.getStringValue(buyerNode) + " "); 
buyerNode = model.getNextSiblingElement(buyerNode);
if (model.matches(buyerNode, "", "zip"))
    buffer.append(model.getStringValue(buyerNode) + "\n");
</programlisting>
                    </para>
                    <para id="paraN1A004E">The above obtains the buyer address. 
     </para>
                    <sidebar id="section_cursor_method">
                        <title id="ttlN1A005A">Cursor Method</title>
                        <para id="paraN1A0060">The Cursor equivalent methods should be clear. However, note that the
          Cursor was left inside the zip element of the shipTo and must be returned to
          the purchaseOrder element before proceeding: 
        </para>
                        <para id="paraN1A0066">
                            <programlisting id="cdblkN1A006B">cursor.moveToParent();
cursor.moveToParent(); 
cursor.moveToFirstChildElementByName("", "billTo");
</programlisting>
                        </para>
                    </sidebar>
                </section>
                <section id="concept_credit_card_data">
                    <title id="ttlN1B000D">Add Data from the Credit Card Element</title>
                    <para id="paraN1B0018">To retrieve information from the credit card element, you must first
        navigate there from the 
        <literal id="cdphN1B001D">billTo</literal> node then get the card number and expiration
        date:
     </para>
                    <para id="paraN1B0024">
                        <programlisting id="cdblkN1B0029">node = model.getNextSiblingElementByName(node, "", "creditcard");
buffer.append(model.getStringValue(node) + "\n"); 
buffer.append(model.getAttributeStringValue(node, "", "expiration"));
</programlisting>
                    </para>
                    <sidebar id="section_cursor_equivalent">
                        <title id="ttlN1B0037">Cursor Method</title>
                        <para id="paraN1B003D">The Cursor equivalent methods are again straightforward:
        </para>
                        <para id="paraN1B0043">
                            <programlisting id="cdblkN1B0048">cursor.moveToParent(); 
cursor.moveToNextSiblingElementByName("", "creditcard");
buffer.append(cursor.getStringValue() + "\n"); 
buffer.append(cursor.getAttributeStringValue("", "expiration"));

String chargeID = cardProcessor.verify(buffer.toString());
String merchantID = getMyMerchantID();
</programlisting>
                        </para>
                    </sidebar>
                </section>
                <section id="concept_submit_bill">
                    <title id="ttlN1C000D">Submit the Bill to the Processor</title>
                    <note id="noteN1C0018">
                        <para>Because axis navigation is not available with the Cursor, the Model
        must be used for this step. 
     </para>
                    </note>
                    <para id="paraN1C001E">Finally, to submit the bill to the cardProcessor, prepare a
        line-delimited string in the format: 
     </para>
                    <para id="paraN1C0024">
                        <literal id="cdphN1C0028">CHARGE_ID\nMERCHANT_ID\nAMOUNT</literal>
                    </para>
                    <para id="paraN1C002F">The axis navigation methods, described in 
        <ulink type="concept" url="c_Axis_Navigation.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1C0034">Axis Navigation</ulink>,
        are used to prepare this data:
     </para>
                    <para id="paraN1C003F">
                        <programlisting id="cdblkN1C0044">node = model.getFirstChildElement(document);
node = model.getFirstChildElementByName(node, "", "items"); 
Iterable&lt;N&gt; items = model.getChildElementsByName(node, "", "item"); 
double totalPrice = 0.0;

for (N item : items) {
    int inStock = checkInventory(model.getAttributeStringValue(item, "", "partNum"));
    int quantity = Integer.valueOf(model.getStringValue(
                      model.getChildElementByName(item, "", "quantity")));
    double unitPrice = Double.valueOf(model.getStringValue(
                          model.getChildElementByName(item, "", "USPrice")));
    double subTotal = unitPrice * ( (inStock &lt; quantity) ? inStock : quantity );
    // subTotal may be *zero* if there's nothing in stock.
    totalPrice += subTotal;
}

cardProcessor.charge(chargeID + "\n" + merchantID + "\n" + totalPrice); warehouse.fulfill(document);
</programlisting>
                    </para>
                </section>
            </section>
        </section>
    </section>

    <section id="concept_modifying">
        <title id="ttlN1D000D">Modifying an XML Document</title>
        <para id="paraN1D0018"><phrase id="phrsN1D001C">GenXDM</phrase>
        uses mutable methods to modify XML in place: 
     </para>
        <itemizedlist id="ul_mutable_apis">
            <listitem id="li_2AF1973D8DDB48CD9AA6F28110219950">
                <para>MutableContext 
        </para>
            </listitem>
            <listitem id="li_2CF6A58B187141A9B43D7E6235216158">
                <para>NodeFactory 
        </para>
            </listitem>
            <listitem id="li_E1F18C61808A48B38D983CDF3D8A7BE5">
                <para>MutableModel/MutableCursor 
        </para>
            </listitem>
        </itemizedlist>
        <note id="noteN1D003F">
            <para>This section assumes that: 
        </para>
            <itemizedlist id="ul_mutant_assumptions">
                <listitem id="li_06573B1A6D854C3FA1E899B9F7A819A0x">
                    <para><emphasis role="italic" id="iN1D004F">context</emphasis> is the
             ProcessingContext&lt;N&gt; created in 
             <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1D0055">Injecting a GenXDM Bridge Implementation</ulink>.
             
          </para>
                </listitem>
                <listitem id="li_B2DBAF5083FA4E7494E0FD4CFCE8D710x">
                    <para><emphasis role="italic" id="iN1D0065">document</emphasis> is the
             document read in 
             <ulink type="concept" url="c_Reading_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1D006B">Reading an XML Document with DocumentHandler</ulink>
             and 
             <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1D0075">Examining an XML Document with Model/Cursor</ulink>.
             
          </para>
                </listitem>
            </itemizedlist>
        </note>
        <para id="paraN1D0082">This section describes how to modify the XML document received in order
        to add an order ID to the purchase. 
     </para>
        <section id="concept_modify_document_example">
            <title id="ttlN1E000D">Example: Modifying a Document</title>
            <para id="paraN1E0018">This example uses 
        <phrase id="phrsN1E001D">GenXDM</phrase>
        to modify the po.xml document shown in 
        <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1E0023">Examining an XML Document with Model/Cursor</ulink>,
        in order to add an order ID to the purchase. 
     </para>
            <para id="paraN1E002E">Note that the po.xml file includes just one customer with a given name
        in a given zip code. 
     </para>
            <orderedlist id="ol_520B50373B0B4D7CB5B3E4527C98FD6D">
                <listitem id="li_402C30D81AEE4F1F899B8CE58833CFFA">
                    <para>Create a static class
          IdGenerator: 
          </para>
                    <para id="paraN1E0040">
                        <programlisting id="cdblkN1E0045">class IdGenerator {

public static String newOrderId() { ... } 

}</programlisting>
                    </para>
                </listitem>
                <listitem id="li_CD22EBDFC6E34FD1A2010A70FC1CA6B9">
                    <para> Obtain the
          MutableContext&lt;N&gt;, and get a MutableModel&lt;N&gt; from there. 
          </para>
                    <para id="paraN1E0054">
                        <programlisting id="cdblkN1E0059">MutableContext&lt;N&gt; mutant = context.getMutableContext(); 
MutableModel&lt;N&gt; mutantModel = mutant.getModel(); 
NodeFactory&lt;N&gt; factory = mutantModel.getFactory(document);</programlisting>
                    </para>
                    <para id="paraN1E0061">Note that the NodeFactory is obtained from the MutableModel, not
             from the MutableContext. This is necessary to avoid ownership issues over the
             DOM bridge: DOM confuses the document node (a container) with the factory for
             creating nodes, and every node has an "owner" document. To avoid the costs
             associated with changing ownership, obtain a NodeFactory from a MutableModel or
             MutableCursor, supplying the owner document node. If you are not using the DOM
             bridge, this is not an issue. 
          </para>
                </listitem>
                <listitem id="li_3822C0D5DE2F4F9E9ABA4BEBB3460E6F">
                    <para>Add the order ID to the
          document: 
          </para>
                    <para id="paraN1E006E">Using Model: 
          </para>
                    <para id="paraN1E0074">
                        <programlisting id="cdblkN1E0079">N node = mutantModel.getFirstChildElement(document);
if (mutantModel.matches(node, "", "purchaseOrder")) {
    N orderId = factory.createAttribute("", "id", "", IdGenerator.newOrderId());
    mutantModel.insertAttribute(node, orderId); 
}</programlisting>
                    </para>
                    <para id="paraN1E0081">Using Cursor: 
          </para>
                    <para id="paraN1E0087">
                        <programlisting id="cdblkN1E008C">MutableCursor&lt;N&gt; mutantCursor = mutant.newCursor(document); 
NodeFactory&lt;N&gt; factory = mutantCursor.getFactory(); 
mutantCursor.moveToFirstChildElement();
if (mutantCursor.matches("", "purchaseOrder")) {
    N orderId = factory.createAttribute("", "id", "", IdGenerator.newOrderId());
    mutantCursor.insertAttribute(orderId);
}</programlisting>
                    </para>
                    <para id="paraN1E0094">Note that the method variation from Model to Cursor is exactly as
             with the immutable base interfaces: "get" becomes "moveTo", and methods do not
             need the first context node argument to methods, "N". 
          </para>
                </listitem>
            </orderedlist>
        </section>
    </section>

    <section id="concept_writing">
        <title id="ttlN1F000D">Writing to a File or Socket with DocumentHandler</title>
        <para id="paraN1F0018">To write your document to a file or a socket, 
        <phrase id="phrsN1F001D">GenXDM</phrase>
        uses DocumentHandler. 
     </para>
        <note id="noteN1F0024">
            <para>This section assumes that: 
        </para>
            <itemizedlist id="ul_writing_assumptions">
                <listitem id="li_06573B1A6D854C3FA1E899B9F7A819A0y">
                    <para><emphasis role="italic" id="iN1F0034">context</emphasis> is the
             ProcessingContext&lt;N&gt; created in 
             <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1F003A">Injecting a GenXDM Bridge Implementation</ulink>.
             
          </para>
                </listitem>
                <listitem id="li_B2DBAF5083FA4E7494E0FD4CFCE8D710y">
                    <para><emphasis role="italic" id="iN1F004A">document</emphasis> is the
             document read in 
             <ulink type="concept" url="c_Reading_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1F0050">Reading an XML Document with DocumentHandler</ulink>
             and 
             <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1F005A">Examining an XML Document with Model/Cursor</ulink>,
             and modified in 
             <ulink type="concept" url="c_Modifying_Documents.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN1F0064">Modifying an XML Document</ulink>.
             
          </para>
                </listitem>
            </itemizedlist>
        </note>
        <para id="paraN1F0071">This section describes how a document is archived to disk.
     </para>
        <section id="concept_write_to_disk">
            <title id="ttlN20000D">Example: Writing to Disk</title>
            <para id="paraN200018">This example uses DocumentHandler to write the po.xml document to disk.
        To archive the document: 
     </para>
            <itemizedlist id="ul_writing_methods">
                <listitem id="li_8749DC535BC944D19119DE7A6BC67C7F">
                    <para>Using a Writer:
          </para>
                    <para id="paraN20002A">
                        <programlisting id="cdblkN20002F">File filename = getUniqueArchivalLocation();
Writer writer = new FileWriter(filename);

DocumentHandler handler = context.newDocumentHandler(); 
handler.write(writer, document);
</programlisting>
                    </para>
                </listitem>
                <listitem id="li_DB3C1ACE14D84728848A38989B5E540A">
                    <para>Using an OutputStream:
          </para>
                    <para id="paraN20003E">
                        <programlisting id="cdblkN200043">URL url = getTargetEndpoint();
URLConnection connection = url.openConnection(); 
OutputStream stream = connection.getOutputStream();

DocumentHandler handler = context.newDocumentHandler(); 
handler.write(stream, document, "UTF-8");
</programlisting>
                    </para>
                </listitem>
            </itemizedlist>
            <note id="noteN20004D">
                <para>Note that 
        <phrase id="phrsN200052">GenXDM</phrase>
        does not currently offer pretty printing capabilities.
     </para>
            </note>
        </section>
    </section>

    <section id="concept_types">
        <title id="ttlN21000D">Implementing Schema Awareness</title>
        <para id="paraN21001E">Schema-aware processing, also called typed processing, uses a schema to
        describe the content, down to the primitive types of certain text and attribute
        nodes, of a category of XML instance documents. With the schema and an
        instance, you can use 
        <phrase id="phrsN210023">GenXDM</phrase>
        to annotate the instance, in a process called "validation". Once an instance
        has been validated, both the type annotation and a typed value (called an
        "atom" and represented by the &lt;A&gt; parameter in the API, so that it may
        differ from bridge to bridge) may be queried from the enhanced (typed or
        schema-aware) Model and Cursor. 
        </para>
        <para id="paraN21002A">The basic steps to implementing schema awareness are: 
        </para>
        <itemizedlist id="ul_schema_steps">
            <listitem id="li_D79691BBA01F426B817C5AB42F10EC33">
                <para>Initialize the schema by
                obtaining an enhanced context and registering the schema components with the
                TypedContext. See 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN21003C">Example: Initializing the Schema Context</ulink>.
                </para>
            </listitem>
            <listitem id="li_E07ED85E54A046449B46628B81E5E8BE">
                <para>Validate the instance
                according to the schema. See 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN21004D">Example: Validating a Document</ulink>.
                </para>
            </listitem>
            <listitem id="li_F9E9465BFBBF4F62B96AA5B3F682B307">
                <para>Review any errors. See 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN21005E">Checking for Errors</ulink>.
                </para>
            </listitem>
            <listitem id="li_C4C37EC476C045AF9F02288573C37BDE">
                <para>Navigate the typed tree. See
                <ulink type="concept" url="c_Navigate_and_Inspect_the_Model.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN21006F">Navigate and Inspect Using Model</ulink>.
                </para>
            </listitem>
        </itemizedlist>
        <section id="concept_initialize_schema">
            <title id="ttlN22000D">Example: Initializing the Schema Context</title>
            <para id="paraN220018">Applications should know in advance what schemas they are handling. Very
            little can be accomplished with a document that is effectively an unknown
            format, containing data (however strongly typed) about which the developers of
            the application know nothing. As a result, the normal flow in preparing for
            schema-aware, typed processing is to begin by registering all the schema
            components defined by the schemas of interest with the TypedContext. 
            </para>
            <note id="noteN22001E">
                <para>This section assumes that:</para>
                <itemizedlist id="ul_type_assumptions">
                    <listitem id="li_06573B1A6D854C3FA1E899B9F7A819A0z">
                        <para><emphasis role="italic" id="iN22002E">context</emphasis> is a
                        ProcessingContext&lt;N&gt;. 
                        </para>
                    </listitem>
                </itemizedlist>
            </note>
            <para id="paraN220037"> In this example, you create an enhanced context and configure a
            SchemaParser to parse the schema.</para>
            <para id="paraN22003D">The enhanced context is the TypedContext. A TypedContext is-a Schema,
            which also defines methods for interactively defining schema components, and
            for registering "bags" of schema components. The Schema has-a ComponentProvider
            and has-a ComponentBag: 
            </para>
            <itemizedlist id="ul_typed_context_content">
                <listitem id="li_D571DB50BF984D95B7B1FC18E42C461C">
                    <para><emphasis role="bold" id="bN22004E">ComponentProvider</emphasis> is
                    a user-accessible interface providing components of a given type by name. 
                    </para>
                </listitem>
                <listitem id="li_3433F9EF778445F1AFBF7A621B932FE9">
                    <para><emphasis role="bold" id="bN22005A">ComponentBag</emphasis> provides
                    access to components by iteration over each of the primary component types. It
                    is mostly useful for bulk handling of schema components. 
                    </para>
                </listitem>
            </itemizedlist>
            <para id="paraN220062">To initialize the Schema: </para>
            <orderedlist id="ol_87F53476EE474A46A9F4FCB0FD82CE28">
                <listitem id="li_A3424DCD803C4FF091E652913D680B46">
                    <para>Register the schema
                    components with the TypedContext. In order to initialize the schema context,
                    you must register the schema components: 
                    </para>
                    <para id="paraN220074">
                        <programlisting id="cdblkN220079">TypedContext&lt;N, A&gt; tcontext = context.getTypedContext();</programlisting>
                    </para>
                    <para id="paraN220081">While it is possible to programmatically create and declare (or
                    define) schema components, the usual method for initializing a schema context
                    is to use a SchemaParser. The SchemaParser interface is defined in the 
                    <literal id="cdphN220086">org.genxdm.xs</literal> package. The 
                    <phrase id="phrsN22008C">GenXDM</phrase>
                    distribution includes a basic implementation of a schema parsing processor, in
                    the module 
                    <literal id="cdphN220092">proc-w3cxs</literal>. This processor implements the
                    SchemaParser interface, which includes several methods which must be called to
                    initialize any parser processor correctly. 
                    </para>
                </listitem>
                <listitem id="li_47B5B6588FF9473589DCA0F046489E8D">
                    <para>Provide the SchemaParser
                    with its "bootstrap" component provider. At a minimum, the bootstrap component
                    provider must define the schema for schema, but also typically defines the XML
                    and schema instance namespaces. 
                    </para>
                    <para id="paraN2200A0">Default <phrase id="phrsN2200A5">GenXDM</phrase>
                    bridges build schema implementations using the utilities in bridgekit, which
                    includes initialization of the bootstrap provider. You can therefore define
                    this code snippet to instantiate and begin initializing the schema parser: 
                    </para>
                    <para id="paraN2200AC">
                        <programlisting id="cdblkN2200B1">SchemaParser schemaParser = new W3cXmlSchemaParser(); 
schemaParser.setComponentProvider(tcontext.getComponentProvider());</programlisting>
                    </para>
                </listitem>
                <listitem id="li_587F9625D3994343B1E303FEF485CA02">
                    <para>Provide the SchemaParser
                    with a resolver. The resolver is needed to handle schema include and import
                    directives. The resolver works with the schema catalog: the catalog can resolve
                    a namespace and schema location, or schema location alone, to return a new URI.
                    That URI is then passed to the catalog resolver to produce an input stream. 
                    </para>
                    <para id="paraN2200C0"> </para>
                    <para>From the SchemaParser interface:</para>
                    <para id="paraN2200C6">
                        <programlisting id="cdblkN2200CB">void setCatalogResolver(CatalogResolver resolver, SchemaCatalog catalog)

SchemaCatalog catalog = new DefaultSchemaCatalog(new DefaultCatalog()); 
schemaParser.setCatalogResolver(DefaultCatalogResolver.SINGLETON,
catalog);
</programlisting>
                    </para>
                    <para id="paraN2200D3">Note that the supplied default catalog resolver is a singleton, so
                    does not need instantiation. 
                    </para>
                    <para id="paraN2200D9"> DefaultSchemaCatalog takes a Catalog in its constructor; proc-w3cxs
                    also provides a default Catalog implementation. The classic implementation of a
                    cataloging resolver locates the necessary information at a remote URI, and then
                    remaps those bits to locally-stored files. However, the default implementations
                    supplied with W3cXmlSchemaParser are not particularly robust, and do not do
                    on-the-fly remapping. For your implementation, you may need to provide
                    alternate implementations rather than using DefaultCatalog and
                    DefaultSchemaCatalog shown in the example above. 
                    </para>
                    <note id="noteN2200DF">
                        <para>There are two more optional methods on the SchemaParser
                        interface, allowing the user to set the regular expression compiler and to set
                        schema load options. However, the W3cXmlSchemaParser ignores options, and
                        chooses a reasonable default for its regular expression compiler. 
                        </para>
                    </note>
                </listitem>
                <listitem id="li_DB8DA43F8A8B4A2BA7B46DDCFB4341A6">
                    <para>Supply an error handler. Two
                    default implementations are provided in the core API: SchemaExceptionCatcher
                    and SchemaExceptionThrower. 
                    </para>
                    <para id="paraN2200EC"> The catcher accumulates errors, which can then be examined after
                    parsing (unless something fatal happens). The thrower offers a stricter
                    approach: it throws an exception when any problem is encountered, stopping
                    further processing. (See 
                    <ulink type="concept" url="c_Checking_for_Errors.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN2200F1">Checking for Errors</ulink>
                    for additional information.) 
                    </para>
                    <para id="paraN2200FC">The simpler approach can be used when the schemas are well-formed
                    and accessible, as are their includes and imports from the resolver, and are
                    valid. In this case, use: 
                    </para>
                    <para id="paraN220102">
                        <programlisting id="cdblkN220107">SchemaExceptionHandler handler = SchemaExceptionThrower.SINGLETON;</programlisting>
                    </para>
                    <note id="noteN22010F">
                        <para id="paraN220114">The signature of the parse method returns a ComponentBag. Note
                        that the Schema interface defines a method to register schema components in
                        bulk, so long as they are provided as component bags. The method also requires
                        a schema location URI and a System ID. Both URIs may be null. If they are not
                        null, the schema location provides the base URI (used for resolution of imports
                        and includes via relative URI), and the System ID is the 'canonical identifier'
                        for this schema document. 
                        </para>
                    </note>
                </listitem>
                <listitem id="li_29D04357FBBF4C9B82FC03F4500B743D">
                    <para>Supply the schema as an InputStream.</para>
                    <para id="paraN220122">Assuming you have an Iterable&lt;URI&gt; of schema locations and
                    want to use the catalog resolver to retrieve the initial input stream (as well
                    as the streams for include and import, which the parser will handle behind the
                    scenes), initialize the context using: 
                    </para>
                    <para id="paraN220128">
                        <programlisting id="cdblkN22012D">for (URI location : locations) {
    InputStream stream =
DefaultCatalogResolver.SINGLETON.resolveInputStream(location);
    ComponentBag components = schemaParser.parse(location, stream, location, handler);
    tcontext.register(components);
}
</programlisting>
                    </para>
                </listitem>
            </orderedlist>
            <para id="paraN220137">Once all of the schemas of interest have been registered with the
            TypedContext&lt;N, A&gt;, the next steps are examples of
            validating-while-parsing, of validating a tree that has been constructed in
            memory or that was parsed without validating, and then of navigating over the
            enhanced, schema-aware model.</para>
        </section>

        <section id="concept_validating">
            <title id="ttlN23000D">Example: Validating a Document</title>
            <note id="noteN230018">
                <para>This section assumes that:</para>
                <itemizedlist id="ul_validation_assumptions">
                    <listitem id="li_FAD20C67EED445E2875370C6579018B7">
                        <para><emphasis role="italic" id="iN230029">tcontext</emphasis> is a TypedContext&lt;N, A&gt;
             (context.getTypedContext()), as prepared in the previous 
             <ulink type="concept" url="c_Initializing_the_Schema_Context.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN23002F">Example: Initializing the Schema Context</ulink>.
             
          </para>
                    </listitem>
                    <listitem id="li_8E32E51A656C44ACA86F616EFAF6CD1C">
                        <para><emphasis role="italic" id="iN230040">document</emphasis> is the document &lt;N&gt;ode of po.xml and has been
             read into the schema context, as described in 
             <ulink type="concept" url="c_Examining_an_XML_Document.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN230046">Examining an XML Document with Model/Cursor</ulink>.
             Note that the changes described in 
             <ulink type="concept" url="c_Modifying_Documents.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN230050">Modifying an XML Document</ulink>
             can not have been applied. 
          </para>
                    </listitem>
                </itemizedlist>
            </note>
            <para id="paraN23005D">Two examples are provided here: 
     </para>
            <itemizedlist id="ul_validation_examples">
                <listitem id="li_1C90C7ED518A41509FD5FA40AAC48F98">
                    <para><ulink type="concept" url="c_Validating_in_Memory.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN23006E">Validating in Memory</ulink>.
          This typically returns a new tree, but may instead decorate the supplied tree. 
        </para>
                </listitem>
                <listitem id="li_C91136EE56CC4DA3A8CECF53CE6CFFCD">
                    <para><ulink type="concept" url="c_Validating_while_Parsing.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN23007E">Validating While Parsing</ulink>.
          This demonstrates how the document can be read with a validator in the
          pipeline, so that the resultant tree of nodes is decorated with types and
          contains atoms. 
        </para>
                </listitem>
            </itemizedlist>
            <para id="paraN23008A">In both of the examples, assume that 
        <emphasis role="italic" id="iN23008F">tcontext</emphasis> has already parsed po.xsd, which defines the schema that
        the sample po.xml uses. 
     </para>
            <sidebar id="section_validator">
                <title id="ttlN23009C">Validator</title>
                <para id="paraN2300A2">The Validator does the work of validating a schema. You must select a
          validation processor, instantiate it, and pass it to the TypedContext. This
          behavior is similar to the SchemaParser: schema parsing defines interfaces but
          does not associate the schema parser with a bridge. You can supply any schema
          parser that implements the interface to any bridge. 
          <phrase id="phrsN2300A7">GenXDM</phrase>
          supplies a validation processor, proc-w3cxs-val. It contains a ValidatorFactory
          in org.genxdm.processor.w3c.xs.validation. 
        </para>
                <para id="paraN2300AE">ValidationHandler is in the org.genxdm.typed package. ValidationHander
          extends both Validator&lt;A&gt; and SequenceHandler&lt;A&gt;. 
        </para>
                <itemizedlist id="ul_validator_interface">
                    <listitem id="li_9620BA4785E946ECAD324E6CF476BBDE">
                        <para><emphasis role="bold" id="bN2300BF">Validator</emphasis> is the
             core interface for validation, used both to validate untyped trees in memory,
             and to validate while parsing. Validator&lt;A&gt; has three methods of interest
             for understanding how validation works: 
             </para>
                        <para id="paraN2300C5">
                            <programlisting id="cdblkN2300CA">void setSchema(Schema cache)
void setSequenceHandler(SequenceHandler&lt;A&gt; handler)
void setSchemaExceptionHandler(SchemaExceptionHandler errors)</programlisting>
                        </para>
                        <para id="paraN2300D2">The first two of these three methods are called by the
                TypedContext&lt;N, A&gt; as part of validation, either through the validate()
                method or the parse() method of the typed I/O API. You do not call them
                directly. 
             </para>
                        <para id="paraN2300D8">You are expected to set the SchemaExceptionHandler. This is the
                same exception handler described in 
                <ulink type="concept" url="c_Initializing_the_Schema_Context.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN2300DD">Example: Initializing the Schema Context</ulink>.
                The two default implementations are SchemaExceptionCatcher and
                SchemaExceptionThrower. If the Thrower is used, the validation/parse halts when
                a validity error is encountered. If the Catcher is used, the validity errors
                are collected, and the user can iterate over them after validation. 
             </para>
                    </listitem>
                    <listitem id="li_532E29A5E16443D4804FE6CB91702733">
                        <para><emphasis role="bold" id="bN2300EE">SequenceHandler</emphasis>
             adds overloaded methods for supplying types to elements and attributes, and
             typed values (atoms) to attributes and text nodes. SequenceHandler is in the
             org.genxdm.typed.io package, and extends ContentHandler (from the org.genxdm.io
             package). 
          </para>
                    </listitem>
                </itemizedlist>
                <para id="paraN2300F6">The TypedContext, when supplied a Validator by way of the validate()
          or TypedDocumentHandlerFactory.newDocumentHandler() methods, sets the schema
          and the sequence handler. The SequenceHandler is the output device that creates
          the tree with type annotations or typed values. 
        </para>
                <para id="paraN2300FC">For example, when given the source &lt;N&gt;ode, the validator, and
          the schema URI in the validate() call, the TypedContext: 
        </para>
                <orderedlist id="ol_5F34DD40449E4C3D8966D1246E8FC6E9">
                    <listitem id="li_D6295D8950EF455292FECFE25E3AAEA1">
                        <para>Sets itself as the schema
             cache for the validator. 
          </para>
                    </listitem>
                    <listitem id="li_956987EAC70440BC82921C7BDE00E868">
                        <para>Sets an appropriate
             sequence handler on the validator (in current implementations, always a
             SequenceBuilder) 
          </para>
                    </listitem>
                    <listitem id="li_A0AC493B89124DD689C6C3098428589E">
                        <para>Passes the source
             &lt;N&gt;ode and the ValidationHandler (which is a SequenceHandler) to the
             TypedModel.stream() method. 
          </para>
                    </listitem>
                </orderedlist>
                <para id="paraN23011E"> The typed model then walks over the document, calling the
          SequenceHandler methods of ValidationHandler for each node, which the
          ValidationHandler passes to the SequenceHandler with which it was initialized,
          after verifying that the values encountered are valid for the specified type. 
        </para>
            </sidebar>
            <section id="concept_po_xsd">
                <title id="ttlN24000D">po.xsd</title>
                <para id="paraN240018">
                    <programlisting id="cdblkN24001D"><![CDATA[<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:element name="purchaseOrder" type="PurchaseOrderType"/>

  <xsd:element name="comment" type="xsd:string"/>

  <xsd:complexType name="PurchaseOrderType">
    <xsd:sequence>
      <xsd:element name="shipTo" type="USAddress"/>
      <xsd:element name="billTo" type="USAddress"/>
      <xsd:element name="creditcard" type="CreditCard"/>
      <xsd:element ref="comment" minOccurs="0"/>
      <xsd:element name="items"  type="Items"/>
    </xsd:sequence>
    <xsd:attribute name="orderDate" type="xsd:date"/>
  </xsd:complexType>

  <xsd:complexType name="USAddress">
    <xsd:sequence>
      <xsd:element name="name"   type="xsd:string"/>
      <xsd:element name="street" type="xsd:string"/>
      <xsd:element name="city"   type="xsd:string"/>
      <xsd:element name="state"  type="xsd:string"/>
      <xsd:element name="zip"    type="xsd:decimal"/>
    </xsd:sequence>
    <xsd:attribute name="country" type="xsd:NMTOKEN"
                   fixed="US"/>
  </xsd:complexType>
  
  <xsd:complexType name="CreditCard">
    <xsd:simpleContent>
      <xsd:restriction base="xsd:string">
        <xsd:pattern value="[0-9]{16}"/>
        <xsd:attribute name="type" type="CCEnum"/>
        <xsd:attribute name="expiration" type="xsd:gYearMonth"/>
      </xsd:restriction>
    </xsd:simpleContent>
  </xsd:complexType>
  
  <xsd:simpleType name="CCEnum">
    <xsd:restriction base="xsd:token">
      <xsd:enumeration value="Visa"/>
      <xsd:enumeration value="MasterCard"/>
      <xsd:enumeration value="AmericanExpress"/>
      <xsd:enumeration value="Discover"/>
      <xsd:enumeration value="JoeBobsCornerPawnshop"/>
    </xsd:restriction>
  </xsd:simpleType>

  <xsd:complexType name="Items">
    <xsd:sequence>
      <xsd:element name="item" minOccurs="0" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="productName" type="xsd:string"/>
            <xsd:element name="quantity">
              <xsd:simpleType>
                <xsd:restriction base="xsd:positiveInteger">
                  <xsd:maxExclusive value="100"/>
                </xsd:restriction>
              </xsd:simpleType>
            </xsd:element>
            <xsd:element name="USPrice"  type="xsd:decimal"/>
            <xsd:element ref="comment"   minOccurs="0"/>
            <xsd:element name="shipDate" type="xsd:date" minOccurs="0"/>
          </xsd:sequence>
          <xsd:attribute name="partNum" type="SKU" use="required"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- Stock Keeping Unit, a code for identifying products -->
  <xsd:simpleType name="SKU">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="\d{3}-[A-Z]{2}"/>
    </xsd:restriction>
  </xsd:simpleType>

</xsd:schema>]]>
</programlisting>
                </para>
            </section>
            <section id="concept_validating_in_memory">
                <title id="ttlN25000D">Validating in Memory</title>
                <para id="paraN250018">This section describes how to validate an existing, untyped tree, using
        a 
        <emphasis role="italic" id="iN25001D">document</emphasis> previously read into the schema context. This po.xml
        documnet is validated against the 
        <ulink type="concept" url="c_po.xsd.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN250023">po.xsd</ulink>
        shown above. 
     </para>
                <para id="paraN25002E">Because the mutable API does not allow typed trees, any changes made to
        the tree invalidate portions of the tree. For this reason, do not use a version
        of the po.xml that was modified in 
        <ulink type="concept" url="c_Modifying_Documents.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN250033">Modifying an XML Document</ulink>.
     </para>
                <para id="paraN25003E">The method needed is found on TypedContext&lt;N, A&gt;: 
     </para>
                <para id="paraN250044">
                    <programlisting id="cdblkN250049">N validate(N source, ValidationHandler&lt;A&gt; validator, URI
schemaNamespace)
</programlisting>
                </para>
                <para id="paraN250051">where: 
     </para>
                <para id="paraN250057">
                    <informaltable id="table_validate_parameters">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="4.48*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">N source 
                </entry>
                                    <entry colname="col2">
                                        <para id="paraN25008D">is the untyped tree that you want to validate. In this
                     example, po.xml. 
                  </para>
                                        <para id="paraN250093">Alternately, use this method to re-validate a typed tree that
                     has been modified in memory. Because the mutable API is untyped-only, any nodes
                     added, or removed, or any other changes made to the tree implicitly invalidate
                     portions of the tree. Specifically, the ancestor-or-self axis is invalidated,
                     with the context set to the modified node. Once changes have been made, this
                     method may be called to validate the modified tree (assuming that those changes
                     did not make the result invalid). 
                  </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry colname="col1">URI schemaNamespace 
                </entry>
                                    <entry colname="col2">
                                        <para id="paraN2500AD">is the target namespace of the schema. In this example, there
                     is no target namespace; this is the empty string: 
                     <literal id="cdphN2500B2">""</literal> (also called the global namespace). 
                  </para>
                                        <para id="paraN2500B9">Using the global namespace is extremely useful for schemas
                     used in examples, because it reduces the clutter and allows us to focus on what
                     we're doing. However, 
                  </para>
                                        <para id="paraN2500BF"> This is considered poor practice for schemas that are used in
                     production, but it is extremely useful for schemas used in examples. So long as
                     there is only one schema with no @targetNamespace attribute (thus putting its
                     components in the global, unnamed namespace represented by the empty string),
                     this is not ambiguous. For this example, po.xsd is the only schema that defines
                     components in this namespace. 
                  </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry colname="col1"> ValidationHandler&lt;A&gt; validator 
                </entry>
                                    <entry colname="col2">
                                        <para id="paraN2500D9">is the validation handler that verifies that the values
                     encountered are valid for the specified type. For more information, see 
                     <ulink type="section" url="c_Validating_Example.xm#concept_EB038B3705124EACBE52D26A151D2A26/section_3AE11313CD2F427F87758C1997B9C8C7" id="linkN2500DE">Validator</ulink>.
                     
                  </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para id="paraN2500EF">For example: 
     </para>
                <para id="paraN2500F5">
                    <programlisting id="cdblkN2500FA">ValidatorFactory&lt;N, A&gt; factory = new ValidatorFactory&lt;N, A&gt;(tcontext);
ValidationHandler&lt;A&gt; validator = factory.newXdmContentValidator();
SchemaExceptionHandler errors = new SchemaExceptionCatcher();
validator.setSchemaExceptionHandler(errors);
N typedDocument = tcontext.validate(document, validator, "");
</programlisting>
                </para>
            </section>
            <section id="concept_validating_parsing">
                <title id="ttlN26000D">Validating While Parsing</title>
                <para id="paraN260018">This section describes how a document can be read using a validator in
        the pipeline, so that the resultant tree of nodes is decorated with types and
        contains atoms. 
     </para>
                <para id="paraN26001E">TypedContext&lt;N, A&gt; is a TypedDocumentHandlerFactory&lt;N, A&gt;.
        TypedDocumentHandlerFactory&lt;N, A&gt; defines one new method: 
     </para>
                <para id="paraN260024">
                    <programlisting id="cdblkN260029">TypedDocumentHandler&lt;N, A&gt; newDocumentHandler(SAXValidator&lt;A&gt;
validator, XMLReporter reporter, Resolver resolver)
</programlisting>
                </para>
                <para id="paraN260031">where: 
     </para>
                <para id="paraN260037">
                    <informaltable id="table_document_handler_parameters">
                        <tgroup cols="2">
                            <colspec colname="col1" colnum="1" colwidth="1.00*"/>
                            <colspec colname="col2" colnum="2" colwidth="4.48*"/>
                            <tbody>
                                <row>
                                    <entry colname="col1">SAXValidator&lt;A&gt; 
                </entry>
                                    <entry colname="col2">is a Validator. It also is a SAX
                  ContentHandler (which is not the same as a GenXDM ContentHandler). See also 
                  <ulink type="section" url="c_Validating_Example.xm#concept_EB038B3705124EACBE52D26A151D2A26/section_3AE11313CD2F427F87758C1997B9C8C7" id="linkN26006D">Validator</ulink>
                  for more information on Validators. 
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">XMLReporter reporter 
                </entry>
                                    <entry colname="col2">is the error handler, as described in 
                  <ulink type="section" url="c_Using_Error_Handlers_and_Resolvers.xm#concept_EB038B3705124EACBE52D26A151D2A26/section_59CECD919B894DB88F832762C6960562" id="linkN26008B">Error Handler</ulink>.
                  In the example that follows, the reporter is null.
                </entry>
                                </row>
                                <row>
                                    <entry colname="col1">Resolver resolver 
                </entry>
                                    <entry colname="col2">is the resolver, as described in 
                  <ulink type="concept" url="c_Initializing_the_Schema_Context.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN2600A9">Example: Initializing the Schema Context</ulink>.
                  
                </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para id="paraN2600B9"> 
     </para>
                <para id="paraN2600BF">The following example also assumes that there is a method: 
     </para>
                <para id="paraN2600C5">
                    <literal id="cdphN2600C9">InputSource getInputSource()</literal>
                </para>
                <para id="paraN2600D0">which returns an initialized InputSource, as discussed in 
        <ulink type="concept" url="c_Initializing_the_Schema_Context.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN2600D5">Example: Initializing the Schema Context</ulink>.
        
     </para>
                <para id="paraN2600E0">For example: 
     </para>
                <para id="paraN2600E6">
                    <programlisting id="cdblkN2600EB">ValidatorFactory&lt;N, A&gt; factory = new ValidatorFactory&lt;N, A&gt;(tcontext); 
SAXValidator&lt;A&gt; validator = factory.newSAXContentValidator();
SchemaExceptionHandler errors = new SchemaExceptionCatcher();
validator.setSchemaExceptionHandler(errors);
TypedDocumentHandler&lt;N, A&gt; parser = tcontext.newDocumentHandler(validator, null, null);
N typedDocument = parser.parse(getInputSource(), null);</programlisting>
                </para>
                <para id="paraN2600F3">
     </para>
            </section>
            <section id="concept_checking_errors">
                <title id="ttlN27000D">Checking for Errors</title>
                <para id="paraN270018">Once you have run the validator over a tree, or while parsing, you
        hopefully have a tree that is valid. If the validator encountered any problems
        during validation, the response depends on the error handler specified during
        initialization. 
     </para>
                <sidebar id="section_schemaexceptionthrower">
                    <title id="ttlN270024">SchemaExceptionThrower</title>
                    <para id="paraN27002A">If the Validator encounters an error and the thrower is the error
          handler deployed, validation failed without completing and a typed tree was not
          generated. 
        </para>
                </sidebar>
                <sidebar id="section_schemaexceptioncatcher">
                    <title id="ttlN270037">SchemaExceptionCatcher</title>
                    <para id="paraN27003D">If the Validator encounters an error and the catcher is the error
          handler deployed, validation completed with errors. You will have a tree, but
          it may not be a fully typed tree. However, the catcher allows you to review
          what if any errors were generated. 
        </para>
                    <para id="paraN270043">SchemaExceptionCatcher is a LinkedList&lt;SchemaException&gt;. For
          example, where 
          <literal id="cdphN270048">errors</literal> is the Catcher created In the validation
          examples, you can check the list of generated errors using: 
        </para>
                    <para id="paraN27004F">
                        <programlisting id="cdblkN270054">for (SchemaException exception : errors) {
    if (exception instanceof SomethingOrOtherException)
      doSomething();
    [more if statements ... ]
    else
      doSomethingElse();
}</programlisting>
                    </para>
                    <para id="paraN27005C">Or alternately: 
        </para>
                    <para id="paraN270062">
                        <programlisting id="cdblkN270067">System.out.println("Invalid!");
for (SchemaException exception : errors) {
    System.out.println(exception.getMessage());
}
</programlisting>
                    </para>
                </sidebar>
            </section>
        </section>

        <section id="concept_examining_typed">
            <title id="ttlN28000D">Navigating and Investigating Typed Documents</title>
            <note id="noteN280018">
                <para>This section assumes that: 
        </para>
                <itemizedlist id="ul_typed_model_assumptions">
                    <listitem id="li_FAD20C67EED445E2875370C6579018B7x">
                        <para><emphasis role="italic" id="iN280029">tcontext</emphasis> is a TypedContext&lt;N, A&gt;, as prepared in the
             previous 
             <ulink type="concept" url="c_Initializing_the_Schema_Context.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN28002F">Example: Initializing the Schema Context</ulink>.
             
          </para>
                    </listitem>
                    <listitem id="li_8E32E51A656C44ACA86F616EFAF6CD1Cx">
                        <para><emphasis role="italic" id="iN280040">typedDocument</emphasis> is the document &lt;N&gt;ode of that was read in
             
             <ulink type="concept" url="c_Validating_Example.xm#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN280046">Example: Validating a Document</ulink>.
             
          </para>
                    </listitem>
                </itemizedlist>
            </note>
            <para id="paraN280053">The TypedModel&lt;N, A&gt; adds five new methods to Model&lt;N&gt;,
        which it extends. All of these methods provide more information (or enhanced
        information transmission, in one case), no new forms or methods for navigation 
     </para>
            <itemizedlist id="ul_typed_model_methods">
                <listitem id="li_9B23EE6FC10447049E87D9FCDB16D4FA">
                    <para>
                        <literal id="cdphN280064">QName
             getAttributeTypeName(N parent, String namespaceURI, String localName)</literal>
                    </para>
                    <para id="paraN28006A"> Called with an element node as context, this method returns the
             type name of the designated attribute, if it exists, and is valid. 
          </para>
                </listitem>
                <listitem id="li_EFC13145FD3847699DF4183D781D0FDC">
                    <para>
                        <literal id="cdphN280076">Iterable&lt;?
             extends A&gt; getAttributeValue(N parent, String namespaceURI, String
             localName)</literal>
                    </para>
                    <para id="paraN28007C"> Called with an element node as context, this method returns the
             content of such a valid attribute, as a list of atoms. 
          </para>
                </listitem>
                <listitem id="li_0E4D11D8B201451289A10D30CF4DF0C1">
                    <para>
                        <literal id="cdphN280088">QName getTypeName(N
             node)</literal>
                    </para>
                    <para id="paraN28008E">Returns null for all node kinds except attribute and element, and
             only returns non-null if the attribute or element is valid. 
          </para>
                </listitem>
                <listitem id="li_5264059FCB764DD7A4E14C7B5FC2596F">
                    <para>
                        <literal id="cdphN28009A">Iterable&lt;?
             extends A&gt; getValue(N node)</literal>
                    </para>
                    <para id="paraN2800A0"> Returns values for all node kinds. Elements with simple content
             return results as expected; comment and processing instructions return their
             (string) content as xs:untypedAtomic. The value of a namespace node is its URI.
             Elements with complex content, and documents, return their XDM value, which is
             the concatenated value of all the nodes in the descendant axis. 
          </para>
                </listitem>
                <listitem id="li_7947E8C87335478DBE05B150673473B6">
                    <para>
                        <literal id="cdphN2800AC"> void stream(N node,
             boolean copyNamespaces, SequenceHandler&lt;A&gt; handler)</literal>
                    </para>
                    <para id="paraN2800B2">Provides a means of streaming information into an enhanced
             ContentHandler, called the SequenceHandler. 
          </para>
                </listitem>
            </itemizedlist>
            <para id="paraN2800BA"> The SequenceHandler (which has already been implicitly used in parsing)
        has several methods added, as overloads, to the ContentHandler interface: 
     </para>
            <itemizedlist id="ol_sequence_handler_methods">
                <listitem id="li_0C71034AD8874E40BD4A5148436C676B">
                    <para>
                        <literal id="cdphN2800CB">void
             attribute(String, String, String, List&lt;? extends A&gt;, QName)</literal>
                    </para>
                    <para id="paraN2800D1">Takes namespace URI, local name, prefix, and then instead of a
             String value and an enumerated DTD attribute type, it takes a list of atoms as
             value and a QName as the type.
          </para>
                </listitem>
                <listitem id="li_33E83904B7C945E28B5DB30B9A9EBECE">
                    <para>
                        <literal id="cdphN2800DD">void
             startElement(String, String, String, QName)</literal>
                    </para>
                    <para id="paraN2800E3">Elements have types, but not values; the startElement method adds an
             argument of type QName that specifies the type.
          </para>
                </listitem>
                <listitem id="li_B652A8C0CE0A4EB3BBF5BF07EF421FCC">
                    <para>
                        <literal id="cdphN2800F0">void text(List&lt;? extends A&gt;)</literal>
                    </para>
                    <para id="paraN2800F6">Simple content of elements appears in text nodes; the text method is
             overridden to accept typed values. The containing element keeps track of the
             type name.
          </para>
                </listitem>
            </itemizedlist>
            <section id="concept_example_examining_typed">
                <title id="ttlN29000D">Example: Navigating and Investigating Typed Documents</title>
                <para id="paraN290018">This example shows how the methods shown above are used to navigate a
                typed document.</para>
                <para id="paraN29001E">To see how this all works, take a look at the schema and the instance
                document, found in typedDocument, and revisit the po.xml document first
                described in 
                <ulink type="concept" url="#concept_EB038B3705124EACBE52D26A151D2A26" id="linkN290023">Examining an XML Document with Model/Cursor</ulink>.</para>
                <para id="paraN29002E">Note first that both shipTo and billTo are of the same type, USAddress.
                USAddress contains a number of child elements with simple content, all of which
                are defined to be strings--except for the zip code, which is defined to be
                xsd:decimal. This is not at all uncommon in schema definitions, although there
                is no need to have decimal or even integer zip codes, since you don't add and
                subtract, multiply and divide zip codes.</para>
                <para id="paraN290034">The credit card's contents are defined as a string with a pattern: 16
                digits. The element has two attributes. One is an enumeration (a restricted
                universe of permitted values, here the allowed credit card types), and the
                other is a date type, in this case gYearMonth.</para>
                <para id="paraN29003A"> According to the schema, the quantity attribute is a positive integer
                with a maximum value of 100. "Positive integer" doesn't include zero, so after
                validation, we know that this contains a number from 1 to 100. The partNum
                element is well-done: it is a control number, with a pattern; we know that it
                matches the numbers in our inventory.</para>
                <para id="paraN290040">Here's a typed example:</para>
                <para id="paraN290046">
                    <programlisting id="cdblkN29004B">TypedModel&lt;N, A&gt; model = tcontext.getModel(); 
N node = model.getFirstChildElement(typedDocument);
node = model.getFirstChildElementByName(node, "", "items"); 
Iterable&lt;N&gt; items = model.getChildElementsByName(node, "", "item"); 
double totalPrice = 0.0; 
AtomBridge&lt;A&gt; atoms = tcontext.getAtomBridge();

for (N item : items) {
    A partNum = model.getAttributeValue(item, "", "partNum").iterator().next();
    int inStock = checkInventory(partNum));

    A quant = model.getValue(model.getChildElementByName(item, "", "quantity"))
                            .iterator().next(); 
    int quantity = atoms.getInt(quant);

    A price = model.getValue(model.getChildElementByName(item, "", "USPrice"))
                             .iterator().next();
    double unitPrice = atoms.getDouble(price);

    double subTotal = unitPrice * ( (inStock &lt; quantity) ? 
                                    inStock : quantity );
    totalPrice += subTotal;
}

cardProcessor.charge(chargeID + "\n" + merchantID + "\n" + totalPrice);
</programlisting>
                </para>
                <sidebar id="section_atombridge">
                    <title id="ttlN290059">AtomBridge</title>
                    <para id="paraN29005F">Note that we have retrieved an AtomBridge from the TypedContext. Just
                    as a Model provides a bridge pattern to investigate a variety of &lt;N&gt;ode
                    implementations, so AtomBridge does for &lt;A&gt;tom implementations.
                    AtomBridge contains a larger number of methods than we wish to list. However,
                    four significant methods are:</para>
                    <itemizedlist id="ul_atombridge_methods">
                        <listitem id="li_F503871793F949779D3C80015724ED90">
                            <para>
                                <literal id="cdphN290070">createTYPENAME()</literal>
                            </para>
                        </listitem>
                        <listitem id="li_2F30FBFECF4246C090BAEA8D708BF09B">
                            <para>
                                <literal id="cdphN290082">compile()</literal>
                            </para>
                        </listitem>
                        <listitem id="li_8DA3B09464A5454BB9C789B2A29E4CCC">
                            <para>
                                <literal id="cdphN29008E">castAs()</literal>
                            </para>
                        </listitem>
                        <listitem id="li_026E572A2D424A9496DF6A7A83273F77">
                            <para>
                                <literal id="cdphN29009A">getTYPENAME()</literal>
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para id="paraN2900A8">To create a new atom, use one of the 
                    <literal id="cdphN2900AD">create()</literal> methods, or use 
                    <literal id="cdphN2900B3">compile()</literal>. Similarly, you can cast an atom as a
                    particular (known) type by calling 
                    <literal id="cdphN2900B9">get()</literal>, or can cast it using the 
                    <literal id="cdphN2900BF">castAs()</literal> method. There are a number of additional
                    methods on the AtomBridge interface, but these are the most immediately
                    interesting. The sample above uses two of the cast methods, based on knowledge
                    of the schema governing the instances that are being examined, and cast
                    directly to the numeric type that is to be manipulated. 
                    </para>
                </sidebar>
            </section>
        </section>
    </section>
</article>
